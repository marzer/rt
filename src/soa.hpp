//----------------------------------------------------------------------------------------------------------------------
// This file was generated by soagen v0.7.0 - do not modify it directly
// https://marzer.github.io/soagen
//----------------------------------------------------------------------------------------------------------------------
#pragma once

#include "colour.hpp"
#include "common.hpp"

#include <soagen.hpp>
#if SOAGEN_VERSION_MAJOR != 0 || SOAGEN_VERSION_MINOR < 7
	#error soagen version mismatch - expected v0.7.X
#endif

SOAGEN_DISABLE_WARNINGS;
SOAGEN_ENABLE_WARNINGS;

SOAGEN_PUSH_WARNINGS;
SOAGEN_DISABLE_SPAM_WARNINGS;
#if SOAGEN_MSVC
	#pragma inline_recursion(on)
#endif
#if SOAGEN_MSVC_LIKE
	#pragma push_macro("min")
	#pragma push_macro("max")
	#undef min
	#undef max
#endif

//----------------------------------------------------------------------------------------------------------------------
// forward declarations + soagen internal boilerplate
//----------------------------------------------------------------------------------------------------------------------

// clang-format off

namespace rt
{
	class boxes;
	class materials;
	class planes;
	class spheres;
}

namespace soagen::detail
{
	#ifndef SOAGEN_NAME_center_x
		#define SOAGEN_NAME_center_x
		SOAGEN_MAKE_NAME(center_x);
	#endif

	#ifndef SOAGEN_NAME_center_y
		#define SOAGEN_NAME_center_y
		SOAGEN_MAKE_NAME(center_y);
	#endif

	#ifndef SOAGEN_NAME_center_z
		#define SOAGEN_NAME_center_z
		SOAGEN_MAKE_NAME(center_z);
	#endif

	#ifndef SOAGEN_NAME_colour
		#define SOAGEN_NAME_colour
		SOAGEN_MAKE_NAME(colour);
	#endif

	#ifndef SOAGEN_NAME_d
		#define SOAGEN_NAME_d
		SOAGEN_MAKE_NAME(d);
	#endif

	#ifndef SOAGEN_NAME_extents_x
		#define SOAGEN_NAME_extents_x
		SOAGEN_MAKE_NAME(extents_x);
	#endif

	#ifndef SOAGEN_NAME_extents_y
		#define SOAGEN_NAME_extents_y
		SOAGEN_MAKE_NAME(extents_y);
	#endif

	#ifndef SOAGEN_NAME_extents_z
		#define SOAGEN_NAME_extents_z
		SOAGEN_MAKE_NAME(extents_z);
	#endif

	#ifndef SOAGEN_NAME_material
		#define SOAGEN_NAME_material
		SOAGEN_MAKE_NAME(material);
	#endif

	#ifndef SOAGEN_NAME_normal_x
		#define SOAGEN_NAME_normal_x
		SOAGEN_MAKE_NAME(normal_x);
	#endif

	#ifndef SOAGEN_NAME_normal_y
		#define SOAGEN_NAME_normal_y
		SOAGEN_MAKE_NAME(normal_y);
	#endif

	#ifndef SOAGEN_NAME_normal_z
		#define SOAGEN_NAME_normal_z
		SOAGEN_MAKE_NAME(normal_z);
	#endif

	#ifndef SOAGEN_NAME_radius
		#define SOAGEN_NAME_radius
		SOAGEN_MAKE_NAME(radius);
	#endif

	#ifndef SOAGEN_NAME_value
		#define SOAGEN_NAME_value
		SOAGEN_MAKE_NAME(value);
	#endif
}

namespace soagen_struct_impl_rt_boxes
{
	SOAGEN_DISABLE_WARNINGS;
	using namespace rt;
	SOAGEN_ENABLE_WARNINGS;

	using soagen_table_traits_type = soagen::table_traits<
					 /* 	value */ soagen::column_traits<rt::box>,
					 /*  material */ soagen::column_traits<size_t>,
					 /*  center_x */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					 /*  center_y */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					 /*  center_z */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					 /* extents_x */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					 /* extents_y */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					 /* extents_z */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>>;

	using soagen_allocator_type = soagen::allocator;
}
namespace soagen_struct_impl_rt_materials
{
	SOAGEN_DISABLE_WARNINGS;
	using namespace rt;
	SOAGEN_ENABLE_WARNINGS;

	using soagen_table_traits_type = soagen::table_traits<
						/* colour */ soagen::column_traits<rt::colour>>;

	using soagen_allocator_type = soagen::allocator;
}
namespace soagen_struct_impl_rt_planes
{
	SOAGEN_DISABLE_WARNINGS;
	using namespace rt;
	SOAGEN_ENABLE_WARNINGS;

	using soagen_table_traits_type = soagen::table_traits<
					  /*	value */ soagen::column_traits<rt::plane>,
					  /* material */ soagen::column_traits<size_t>,
					  /* normal_x */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					  /* normal_y */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					  /* normal_z */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					  /*		d */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>>;

	using soagen_allocator_type = soagen::allocator;
}
namespace soagen_struct_impl_rt_spheres
{
	SOAGEN_DISABLE_WARNINGS;
	using namespace rt;
	SOAGEN_ENABLE_WARNINGS;

	using soagen_table_traits_type = soagen::table_traits<
					  /*	value */ soagen::column_traits<rt::sphere>,
					  /* material */ soagen::column_traits<size_t>,
					  /* center_x */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					  /* center_y */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					  /* center_z */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					  /*   radius */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>>;

	using soagen_allocator_type = soagen::allocator;
}

namespace soagen::detail
{
	SOAGEN_MAKE_NAMED_COLUMN(rt::boxes, 0, value);
	SOAGEN_MAKE_NAMED_COLUMN(rt::boxes, 1, material);
	SOAGEN_MAKE_NAMED_COLUMN(rt::boxes, 2, center_x);
	SOAGEN_MAKE_NAMED_COLUMN(rt::boxes, 3, center_y);
	SOAGEN_MAKE_NAMED_COLUMN(rt::boxes, 4, center_z);
	SOAGEN_MAKE_NAMED_COLUMN(rt::boxes, 5, extents_x);
	SOAGEN_MAKE_NAMED_COLUMN(rt::boxes, 6, extents_y);
	SOAGEN_MAKE_NAMED_COLUMN(rt::boxes, 7, extents_z);

	template <>
	struct is_soa_<rt::boxes> : std::true_type
	{};

	template <>
	struct table_traits_type_<rt::boxes>
	{
		using type = soagen_struct_impl_rt_boxes::soagen_table_traits_type;
	};

	template <>
	struct allocator_type_<rt::boxes>
	{
		using type = soagen_struct_impl_rt_boxes::soagen_allocator_type;
	};

	template <>
	struct table_type_<rt::boxes>
	{
		using type = table<table_traits_type<rt::boxes>, allocator_type<rt::boxes>>;
	};

	SOAGEN_MAKE_NAMED_COLUMN(rt::materials, 0, colour);

	template <>
	struct is_soa_<rt::materials> : std::true_type
	{};

	template <>
	struct table_traits_type_<rt::materials>
	{
		using type = soagen_struct_impl_rt_materials::soagen_table_traits_type;
	};

	template <>
	struct allocator_type_<rt::materials>
	{
		using type = soagen_struct_impl_rt_materials::soagen_allocator_type;
	};

	template <>
	struct table_type_<rt::materials>
	{
		using type = table<table_traits_type<rt::materials>, allocator_type<rt::materials>>;
	};

	SOAGEN_MAKE_NAMED_COLUMN(rt::planes, 0, value);
	SOAGEN_MAKE_NAMED_COLUMN(rt::planes, 1, material);
	SOAGEN_MAKE_NAMED_COLUMN(rt::planes, 2, normal_x);
	SOAGEN_MAKE_NAMED_COLUMN(rt::planes, 3, normal_y);
	SOAGEN_MAKE_NAMED_COLUMN(rt::planes, 4, normal_z);
	SOAGEN_MAKE_NAMED_COLUMN(rt::planes, 5, d);

	template <>
	struct is_soa_<rt::planes> : std::true_type
	{};

	template <>
	struct table_traits_type_<rt::planes>
	{
		using type = soagen_struct_impl_rt_planes::soagen_table_traits_type;
	};

	template <>
	struct allocator_type_<rt::planes>
	{
		using type = soagen_struct_impl_rt_planes::soagen_allocator_type;
	};

	template <>
	struct table_type_<rt::planes>
	{
		using type = table<table_traits_type<rt::planes>, allocator_type<rt::planes>>;
	};

	SOAGEN_MAKE_NAMED_COLUMN(rt::spheres, 0, value);
	SOAGEN_MAKE_NAMED_COLUMN(rt::spheres, 1, material);
	SOAGEN_MAKE_NAMED_COLUMN(rt::spheres, 2, center_x);
	SOAGEN_MAKE_NAMED_COLUMN(rt::spheres, 3, center_y);
	SOAGEN_MAKE_NAMED_COLUMN(rt::spheres, 4, center_z);
	SOAGEN_MAKE_NAMED_COLUMN(rt::spheres, 5, radius);

	template <>
	struct is_soa_<rt::spheres> : std::true_type
	{};

	template <>
	struct table_traits_type_<rt::spheres>
	{
		using type = soagen_struct_impl_rt_spheres::soagen_table_traits_type;
	};

	template <>
	struct allocator_type_<rt::spheres>
	{
		using type = soagen_struct_impl_rt_spheres::soagen_allocator_type;
	};

	template <>
	struct table_type_<rt::spheres>
	{
		using type = table<table_traits_type<rt::spheres>, allocator_type<rt::spheres>>;
	};
}

// clang-format on

//----------------------------------------------------------------------------------------------------------------------
// boxes
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	class SOAGEN_EMPTY_BASES boxes //
		: public soagen::mixins::size_and_capacity<boxes>,
		  public soagen::mixins::resizable<boxes>,
		  public soagen::mixins::equality_comparable<boxes>,
		  public soagen::mixins::less_than_comparable<boxes>,
		  public soagen::mixins::data_ptr<boxes>,
		  public soagen::mixins::columns<boxes>,
		  public soagen::mixins::rows<boxes>,
		  public soagen::mixins::iterators<boxes>,
		  public soagen::mixins::spans<boxes>,
		  public soagen::mixins::swappable<boxes>
	{
	  public:
		using size_type = std::size_t;

		using difference_type = std::ptrdiff_t;

		using allocator_type = soagen::allocator_type<boxes>;

		using table_type = soagen::table_type<boxes>;

		using table_traits = soagen::table_traits_type<boxes>;

		static constexpr size_type column_count = table_traits::column_count;

		template <auto Column>
		using column_traits = typename table_traits::template column<static_cast<size_type>(Column)>;

		template <auto Column>
		using column_type = typename column_traits<static_cast<size_type>(Column)>::value_type;

		using iterator = soagen::iterator_type<boxes>;

		using rvalue_iterator = soagen::rvalue_iterator_type<boxes>;

		using const_iterator = soagen::const_iterator_type<boxes>;

		using span_type = soagen::span_type<boxes>;

		using rvalue_span_type = soagen::rvalue_span_type<boxes>;

		using const_span_type = soagen::const_span_type<boxes>;

		using row_type = soagen::row_type<boxes>;

		using rvalue_row_type = soagen::rvalue_row_type<boxes>;

		using const_row_type = soagen::const_row_type<boxes>;

		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		enum class columns : size_type
		{
			value	  = 0,
			material  = 1,
			center_x  = 2,
			center_y  = 3,
			center_z  = 4,
			extents_x = 5,
			extents_y = 6,
			extents_z = 7,
		};

		template <auto Column>
		static constexpr auto& column_name = soagen::detail::column_name<boxes, static_cast<size_type>(Column)>::value;

	  private:
		table_type table_;

	  public:
		SOAGEN_NODISCARD_CTOR
		boxes() = default;

		SOAGEN_NODISCARD_CTOR
		boxes(boxes&&) = default;

		boxes& operator=(boxes&&) = default;

		SOAGEN_NODISCARD_CTOR
		boxes(const boxes&) = default;

		boxes& operator=(const boxes&) = default;

		~boxes() = default;

		SOAGEN_NODISCARD_CTOR
		constexpr explicit boxes(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		SOAGEN_NODISCARD_CTOR
		constexpr explicit boxes(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&() noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&&() noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator const table_type&() const noexcept
		{
			return table_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR									   //
		std::enable_if_t<sfinae, boxes&> erase(size_type pos)	   //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(pos);
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR																 //
		std::enable_if_t<sfinae, soagen::optional<size_type>> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)				 //
		{
			return table_.unordered_erase(pos);
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> erase(iterator pos)	   //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<iterator>> unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)			   //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type>)		   //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<const_iterator>> unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)						   //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		template <auto A, auto B>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& swap_columns() //
			noexcept(noexcept(std::declval<table_type&>()
								  .template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>()))
		{
			table_.template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>();
			return *this;
		}

		// ------ push_back() --------------------------------------------------------------------------

		SOAGEN_CPP20_CONSTEXPR
		boxes& push_back(column_traits<0>::param_type value,
						 column_traits<1>::param_type material,
						 column_traits<2>::param_type center_x,
						 column_traits<3>::param_type center_y,
						 column_traits<4>::param_type center_z,
						 column_traits<5>::param_type extents_x,
						 column_traits<6>::param_type extents_y,
						 column_traits<7>::param_type extents_z)	 //
			noexcept(table_traits::push_back_is_nothrow<table_type>) //
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(value),
								static_cast<column_traits<1>::param_forward_type>(material),
								static_cast<column_traits<2>::param_forward_type>(center_x),
								static_cast<column_traits<3>::param_forward_type>(center_y),
								static_cast<column_traits<4>::param_forward_type>(center_z),
								static_cast<column_traits<5>::param_forward_type>(extents_x),
								static_cast<column_traits<6>::param_forward_type>(extents_y),
								static_cast<column_traits<7>::param_forward_type>(extents_z));
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::rvalues_are_distinct)
		SOAGEN_CPP20_CONSTEXPR
		boxes& push_back(column_traits<0>::rvalue_type value,
						 column_traits<1>::rvalue_type material,
						 column_traits<2>::rvalue_type center_x,
						 column_traits<3>::rvalue_type center_y,
						 column_traits<4>::rvalue_type center_z,
						 column_traits<5>::rvalue_type extents_x,
						 column_traits<6>::rvalue_type extents_y,
						 column_traits<7>::rvalue_type extents_z)			//
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type>) //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(value),
								static_cast<column_traits<1>::rvalue_forward_type>(material),
								static_cast<column_traits<2>::rvalue_forward_type>(center_x),
								static_cast<column_traits<3>::rvalue_forward_type>(center_y),
								static_cast<column_traits<4>::rvalue_forward_type>(center_z),
								static_cast<column_traits<5>::rvalue_forward_type>(extents_x),
								static_cast<column_traits<6>::rvalue_forward_type>(extents_y),
								static_cast<column_traits<7>::rvalue_forward_type>(extents_z));
			return *this;
		}

		// ------ emplace_back() -----------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE((table_traits::row_constructible_from<Value&&,
																		  Material&&,
																		  CenterX&&,
																		  CenterY&&,
																		  CenterZ&&,
																		  ExtentsX&&,
																		  ExtentsY&&,
																		  ExtentsZ&&>), //
									typename Value,
									typename Material,
									typename CenterX,
									typename CenterY,
									typename CenterZ,
									typename ExtentsX,
									typename ExtentsY,
									typename ExtentsZ) //
		SOAGEN_CPP20_CONSTEXPR
		boxes& emplace_back(Value&& value,
							Material&& material,
							CenterX&& center_x,
							CenterY&& center_y,
							CenterZ&& center_z,
							ExtentsX&& extents_x,
							ExtentsY&& extents_y,
							ExtentsZ&& extents_z) //
			noexcept(table_traits::emplace_back_is_nothrow<table_type,
														   Value&&,
														   Material&&,
														   CenterX&&,
														   CenterY&&,
														   CenterZ&&,
														   ExtentsX&&,
														   ExtentsY&&,
														   ExtentsZ&&>) //
		{
			table_.emplace_back(static_cast<Value&&>(value),
								static_cast<Material&&>(material),
								static_cast<CenterX&&>(center_x),
								static_cast<CenterY&&>(center_y),
								static_cast<CenterZ&&>(center_z),
								static_cast<ExtentsX&&>(extents_x),
								static_cast<ExtentsY&&>(extents_y),
								static_cast<ExtentsZ&&>(extents_z));
			return *this;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(table_traits::row_constructible_from<Tuple>, typename Tuple)
		SOAGEN_CPP20_CONSTEXPR
		boxes& emplace_back(Tuple&& tuple_)										 //
			noexcept(table_traits::emplace_back_is_nothrow<table_type, Tuple&&>) //
		{
			table_.emplace_back(static_cast<Tuple&&>(tuple_));
			return *this;
		}

	  private:
		static constexpr bool can_insert_ =
			table_traits::all_move_or_copy_constructible && table_traits::all_move_or_copy_assignable;

		static constexpr bool can_insert_rvalues_ = can_insert_ && table_traits::rvalues_are_distinct;

	  public:
		// ------ insert(size_type) --------------------------------------------------------------------

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, boxes&> insert(size_type index_,
												column_traits<0>::param_type value,
												column_traits<1>::param_type material,
												column_traits<2>::param_type center_x,
												column_traits<3>::param_type center_y,
												column_traits<4>::param_type center_z,
												column_traits<5>::param_type extents_x,
												column_traits<6>::param_type extents_y,
												column_traits<7>::param_type extents_z) //
			noexcept(table_traits::insert_is_nothrow<table_type>)						//
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(center_x),
						   static_cast<column_traits<3>::param_forward_type>(center_y),
						   static_cast<column_traits<4>::param_forward_type>(center_z),
						   static_cast<column_traits<5>::param_forward_type>(extents_x),
						   static_cast<column_traits<6>::param_forward_type>(extents_y),
						   static_cast<column_traits<7>::param_forward_type>(extents_z));
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		boxes& insert(std::enable_if_t<sfinae, size_type> index_,
					  column_traits<0>::rvalue_type value,
					  column_traits<1>::rvalue_type material,
					  column_traits<2>::rvalue_type center_x,
					  column_traits<3>::rvalue_type center_y,
					  column_traits<4>::rvalue_type center_z,
					  column_traits<5>::rvalue_type extents_x,
					  column_traits<6>::rvalue_type extents_y,
					  column_traits<7>::rvalue_type extents_z)	  //
			noexcept(table_traits::insert_is_nothrow<table_type>) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(extents_x),
						   static_cast<column_traits<6>::rvalue_forward_type>(extents_y),
						   static_cast<column_traits<7>::rvalue_forward_type>(extents_z));
			return *this;
		}

		// ------ insert(iterator) ---------------------------------------------------------------------

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> insert(iterator iter_,
												  column_traits<0>::param_type value,
												  column_traits<1>::param_type material,
												  column_traits<2>::param_type center_x,
												  column_traits<3>::param_type center_y,
												  column_traits<4>::param_type center_z,
												  column_traits<5>::param_type extents_x,
												  column_traits<6>::param_type extents_y,
												  column_traits<7>::param_type extents_z) //
			noexcept(table_traits::insert_is_nothrow<table_type>)						  //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(center_x),
						   static_cast<column_traits<3>::param_forward_type>(center_y),
						   static_cast<column_traits<4>::param_forward_type>(center_z),
						   static_cast<column_traits<5>::param_forward_type>(extents_x),
						   static_cast<column_traits<6>::param_forward_type>(extents_y),
						   static_cast<column_traits<7>::param_forward_type>(extents_z));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> insert(const_iterator iter_,
														column_traits<0>::param_type value,
														column_traits<1>::param_type material,
														column_traits<2>::param_type center_x,
														column_traits<3>::param_type center_y,
														column_traits<4>::param_type center_z,
														column_traits<5>::param_type extents_x,
														column_traits<6>::param_type extents_y,
														column_traits<7>::param_type extents_z) //
			noexcept(table_traits::insert_is_nothrow<table_type>)								//
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(center_x),
						   static_cast<column_traits<3>::param_forward_type>(center_y),
						   static_cast<column_traits<4>::param_forward_type>(center_z),
						   static_cast<column_traits<5>::param_forward_type>(extents_x),
						   static_cast<column_traits<6>::param_forward_type>(extents_y),
						   static_cast<column_traits<7>::param_forward_type>(extents_z));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(std::enable_if_t<sfinae, iterator> iter_,
						column_traits<0>::rvalue_type value,
						column_traits<1>::rvalue_type material,
						column_traits<2>::rvalue_type center_x,
						column_traits<3>::rvalue_type center_y,
						column_traits<4>::rvalue_type center_z,
						column_traits<5>::rvalue_type extents_x,
						column_traits<6>::rvalue_type extents_y,
						column_traits<7>::rvalue_type extents_z)  //
			noexcept(table_traits::insert_is_nothrow<table_type>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(extents_x),
						   static_cast<column_traits<6>::rvalue_forward_type>(extents_y),
						   static_cast<column_traits<7>::rvalue_forward_type>(extents_z));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(std::enable_if_t<sfinae, const_iterator> iter_,
							  column_traits<0>::rvalue_type value,
							  column_traits<1>::rvalue_type material,
							  column_traits<2>::rvalue_type center_x,
							  column_traits<3>::rvalue_type center_y,
							  column_traits<4>::rvalue_type center_z,
							  column_traits<5>::rvalue_type extents_x,
							  column_traits<6>::rvalue_type extents_y,
							  column_traits<7>::rvalue_type extents_z) //
			noexcept(table_traits::insert_is_nothrow<table_type>)	   //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(extents_x),
						   static_cast<column_traits<6>::rvalue_forward_type>(extents_y),
						   static_cast<column_traits<7>::rvalue_forward_type>(extents_z));
			return iter_;
		}

		// ------ emplace(size_type) -------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Value,
									typename Material,
									typename CenterX,
									typename CenterY,
									typename CenterZ,
									typename ExtentsX,
									typename ExtentsY,
									typename ExtentsZ,
									bool sfinae = table_traits::row_constructible_from<Value&&,
																					   Material&&,
																					   CenterX&&,
																					   CenterY&&,
																					   CenterZ&&,
																					   ExtentsX&&,
																					   ExtentsY&&,
																					   ExtentsZ&&>
											   && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, boxes&> emplace(size_type index_,
												 Value&& value,
												 Material&& material,
												 CenterX&& center_x,
												 CenterY&& center_y,
												 CenterZ&& center_z,
												 ExtentsX&& extents_x,
												 ExtentsY&& extents_y,
												 ExtentsZ&& extents_z) //
			noexcept(table_traits::emplace_is_nothrow<table_type,
													  Value&&,
													  Material&&,
													  CenterX&&,
													  CenterY&&,
													  CenterZ&&,
													  ExtentsX&&,
													  ExtentsY&&,
													  ExtentsZ&&>) //
		{
			table_.emplace(index_,
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<ExtentsX&&>(extents_x),
						   static_cast<ExtentsY&&>(extents_y),
						   static_cast<ExtentsZ&&>(extents_z));
			return *this;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		boxes& emplace(std::enable_if_t<sfinae, size_type> index_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)		   //
		{
			table_.emplace(index_, static_cast<Tuple&&>(tuple_));
			return *this;
		}

		// ------ emplace(iterator) --------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Value,
									typename Material,
									typename CenterX,
									typename CenterY,
									typename CenterZ,
									typename ExtentsX,
									typename ExtentsY,
									typename ExtentsZ,
									bool sfinae = table_traits::row_constructible_from<Value&&,
																					   Material&&,
																					   CenterX&&,
																					   CenterY&&,
																					   CenterZ&&,
																					   ExtentsX&&,
																					   ExtentsY&&,
																					   ExtentsZ&&>
											   && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> emplace(iterator iter_,
												   Value&& value,
												   Material&& material,
												   CenterX&& center_x,
												   CenterY&& center_y,
												   CenterZ&& center_z,
												   ExtentsX&& extents_x,
												   ExtentsY&& extents_y,
												   ExtentsZ&& extents_z) //
			noexcept(table_traits::emplace_is_nothrow<table_type,
													  Value&&,
													  Material&&,
													  CenterX&&,
													  CenterY&&,
													  CenterZ&&,
													  ExtentsX&&,
													  ExtentsY&&,
													  ExtentsZ&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<ExtentsX&&>(extents_x),
						   static_cast<ExtentsY&&>(extents_y),
						   static_cast<ExtentsZ&&>(extents_z));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		iterator emplace(std::enable_if_t<sfinae, iterator> iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)		   //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Value,
									typename Material,
									typename CenterX,
									typename CenterY,
									typename CenterZ,
									typename ExtentsX,
									typename ExtentsY,
									typename ExtentsZ,
									bool sfinae = table_traits::row_constructible_from<Value&&,
																					   Material&&,
																					   CenterX&&,
																					   CenterY&&,
																					   CenterZ&&,
																					   ExtentsX&&,
																					   ExtentsY&&,
																					   ExtentsZ&&>
											   && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> emplace(const_iterator iter_,
														 Value&& value,
														 Material&& material,
														 CenterX&& center_x,
														 CenterY&& center_y,
														 CenterZ&& center_z,
														 ExtentsX&& extents_x,
														 ExtentsY&& extents_y,
														 ExtentsZ&& extents_z) //
			noexcept(table_traits::emplace_is_nothrow<table_type,
													  Value&&,
													  Material&&,
													  CenterX&&,
													  CenterY&&,
													  CenterZ&&,
													  ExtentsX&&,
													  ExtentsY&&,
													  ExtentsZ&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<ExtentsX&&>(extents_x),
						   static_cast<ExtentsY&&>(extents_y),
						   static_cast<ExtentsZ&&>(extents_z));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator emplace(std::enable_if_t<sfinae, const_iterator> iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)					   //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		template <auto Column>
		SOAGEN_COLUMN(boxes, Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<boxes, Column>>(table_.template column<Column>());
		}

		template <auto Column>
		SOAGEN_COLUMN(boxes, Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<boxes, Column>>(table_.template column<Column>());
		}
	};

	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<boxes>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(boxes& lhs, boxes& rhs) //
		noexcept(soagen::has_nothrow_swap_member<boxes>)
	{
		lhs.swap(rhs);
	}
}

//----------------------------------------------------------------------------------------------------------------------
// materials
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	class SOAGEN_EMPTY_BASES materials //
		: public soagen::mixins::size_and_capacity<materials>,
		  public soagen::mixins::resizable<materials>,
		  public soagen::mixins::equality_comparable<materials>,
		  public soagen::mixins::less_than_comparable<materials>,
		  public soagen::mixins::data_ptr<materials>,
		  public soagen::mixins::columns<materials>,
		  public soagen::mixins::rows<materials>,
		  public soagen::mixins::iterators<materials>,
		  public soagen::mixins::spans<materials>,
		  public soagen::mixins::swappable<materials>
	{
	  public:
		using size_type = std::size_t;

		using difference_type = std::ptrdiff_t;

		using allocator_type = soagen::allocator_type<materials>;

		using table_type = soagen::table_type<materials>;

		using table_traits = soagen::table_traits_type<materials>;

		static constexpr size_type column_count = table_traits::column_count;

		template <auto Column>
		using column_traits = typename table_traits::template column<static_cast<size_type>(Column)>;

		template <auto Column>
		using column_type = typename column_traits<static_cast<size_type>(Column)>::value_type;

		using iterator = soagen::iterator_type<materials>;

		using rvalue_iterator = soagen::rvalue_iterator_type<materials>;

		using const_iterator = soagen::const_iterator_type<materials>;

		using span_type = soagen::span_type<materials>;

		using rvalue_span_type = soagen::rvalue_span_type<materials>;

		using const_span_type = soagen::const_span_type<materials>;

		using row_type = soagen::row_type<materials>;

		using rvalue_row_type = soagen::rvalue_row_type<materials>;

		using const_row_type = soagen::const_row_type<materials>;

		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		enum class columns : size_type
		{
			colour = 0,
		};

		template <auto Column>
		static constexpr auto& column_name =
			soagen::detail::column_name<materials, static_cast<size_type>(Column)>::value;

	  private:
		table_type table_;

	  public:
		SOAGEN_NODISCARD_CTOR
		materials() = default;

		SOAGEN_NODISCARD_CTOR
		materials(materials&&) = default;

		materials& operator=(materials&&) = default;

		SOAGEN_NODISCARD_CTOR
		materials(const materials&) = default;

		materials& operator=(const materials&) = default;

		~materials() = default;

		SOAGEN_NODISCARD_CTOR
		constexpr explicit materials(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		SOAGEN_NODISCARD_CTOR
		constexpr explicit materials(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&() noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&&() noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator const table_type&() const noexcept
		{
			return table_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR									   //
		std::enable_if_t<sfinae, materials&> erase(size_type pos)  //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(pos);
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR																 //
		std::enable_if_t<sfinae, soagen::optional<size_type>> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)				 //
		{
			return table_.unordered_erase(pos);
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> erase(iterator pos)	   //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<iterator>> unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)			   //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type>)		   //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<const_iterator>> unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)						   //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		template <auto A, auto B>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		materials& swap_columns() //
			noexcept(noexcept(std::declval<table_type&>()
								  .template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>()))
		{
			table_.template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>();
			return *this;
		}

		// ------ push_back() --------------------------------------------------------------------------

		SOAGEN_CPP20_CONSTEXPR
		materials& push_back(column_traits<0>::param_type colour)	 //
			noexcept(table_traits::push_back_is_nothrow<table_type>) //
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(colour));
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::rvalues_are_distinct)
		SOAGEN_CPP20_CONSTEXPR
		materials& push_back(column_traits<0>::rvalue_type colour)			//
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type>) //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(colour));
			return *this;
		}

		// ------ emplace_back() -----------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE((table_traits::row_constructible_from<Colour&&>), //
									typename Colour)								  //
		SOAGEN_CPP20_CONSTEXPR
		materials& emplace_back(Colour&& colour)								  //
			noexcept(table_traits::emplace_back_is_nothrow<table_type, Colour&&>) //
		{
			table_.emplace_back(static_cast<Colour&&>(colour));
			return *this;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(table_traits::row_constructible_from<Tuple>, typename Tuple)
		SOAGEN_CPP20_CONSTEXPR
		materials& emplace_back(Tuple&& tuple_)									 //
			noexcept(table_traits::emplace_back_is_nothrow<table_type, Tuple&&>) //
		{
			table_.emplace_back(static_cast<Tuple&&>(tuple_));
			return *this;
		}

	  private:
		static constexpr bool can_insert_ =
			table_traits::all_move_or_copy_constructible && table_traits::all_move_or_copy_assignable;

		static constexpr bool can_insert_rvalues_ = can_insert_ && table_traits::rvalues_are_distinct;

	  public:
		// ------ insert(size_type) --------------------------------------------------------------------

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, materials&> insert(size_type index_, column_traits<0>::param_type colour) //
			noexcept(table_traits::insert_is_nothrow<table_type>)										   //
		{
			table_.emplace(index_, static_cast<column_traits<0>::param_forward_type>(colour));
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		materials& insert(std::enable_if_t<sfinae, size_type> index_, column_traits<0>::rvalue_type colour) //
			noexcept(table_traits::insert_is_nothrow<table_type>)											//
		{
			table_.emplace(index_, static_cast<column_traits<0>::rvalue_forward_type>(colour));
			return *this;
		}

		// ------ insert(iterator) ---------------------------------------------------------------------

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> insert(iterator iter_, column_traits<0>::param_type colour) //
			noexcept(table_traits::insert_is_nothrow<table_type>)									   //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<column_traits<0>::param_forward_type>(colour));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> insert(const_iterator iter_, column_traits<0>::param_type colour) //
			noexcept(table_traits::insert_is_nothrow<table_type>)												   //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<column_traits<0>::param_forward_type>(colour));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(std::enable_if_t<sfinae, iterator> iter_, column_traits<0>::rvalue_type colour) //
			noexcept(table_traits::insert_is_nothrow<table_type>)										//
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<column_traits<0>::rvalue_forward_type>(colour));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(std::enable_if_t<sfinae, const_iterator> iter_, column_traits<0>::rvalue_type colour) //
			noexcept(table_traits::insert_is_nothrow<table_type>)													//
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<column_traits<0>::rvalue_forward_type>(colour));
			return iter_;
		}

		// ------ emplace(size_type) -------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Colour,
									bool sfinae = table_traits::row_constructible_from<Colour&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, materials&> emplace(size_type index_, Colour&& colour) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Colour&&>)			//
		{
			table_.emplace(index_, static_cast<Colour&&>(colour));
			return *this;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		materials& emplace(std::enable_if_t<sfinae, size_type> index_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)			   //
		{
			table_.emplace(index_, static_cast<Tuple&&>(tuple_));
			return *this;
		}

		// ------ emplace(iterator) --------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Colour,
									bool sfinae = table_traits::row_constructible_from<Colour&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> emplace(iterator iter_, Colour&& colour) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Colour&&>)		//
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Colour&&>(colour));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		iterator emplace(std::enable_if_t<sfinae, iterator> iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)		   //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Colour,
									bool sfinae = table_traits::row_constructible_from<Colour&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> emplace(const_iterator iter_, Colour&& colour) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Colour&&>)					//
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Colour&&>(colour));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator emplace(std::enable_if_t<sfinae, const_iterator> iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)					   //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		template <auto Column>
		SOAGEN_COLUMN(materials, Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<materials, Column>>(
				table_.template column<Column>());
		}

		template <auto Column>
		SOAGEN_COLUMN(materials, Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<materials, Column>>(
				table_.template column<Column>());
		}
	};

	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<materials>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(materials& lhs, materials& rhs) //
		noexcept(soagen::has_nothrow_swap_member<materials>)
	{
		lhs.swap(rhs);
	}
}

//----------------------------------------------------------------------------------------------------------------------
// planes
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	class SOAGEN_EMPTY_BASES planes //
		: public soagen::mixins::size_and_capacity<planes>,
		  public soagen::mixins::resizable<planes>,
		  public soagen::mixins::equality_comparable<planes>,
		  public soagen::mixins::less_than_comparable<planes>,
		  public soagen::mixins::data_ptr<planes>,
		  public soagen::mixins::columns<planes>,
		  public soagen::mixins::rows<planes>,
		  public soagen::mixins::iterators<planes>,
		  public soagen::mixins::spans<planes>,
		  public soagen::mixins::swappable<planes>
	{
	  public:
		using size_type = std::size_t;

		using difference_type = std::ptrdiff_t;

		using allocator_type = soagen::allocator_type<planes>;

		using table_type = soagen::table_type<planes>;

		using table_traits = soagen::table_traits_type<planes>;

		static constexpr size_type column_count = table_traits::column_count;

		template <auto Column>
		using column_traits = typename table_traits::template column<static_cast<size_type>(Column)>;

		template <auto Column>
		using column_type = typename column_traits<static_cast<size_type>(Column)>::value_type;

		using iterator = soagen::iterator_type<planes>;

		using rvalue_iterator = soagen::rvalue_iterator_type<planes>;

		using const_iterator = soagen::const_iterator_type<planes>;

		using span_type = soagen::span_type<planes>;

		using rvalue_span_type = soagen::rvalue_span_type<planes>;

		using const_span_type = soagen::const_span_type<planes>;

		using row_type = soagen::row_type<planes>;

		using rvalue_row_type = soagen::rvalue_row_type<planes>;

		using const_row_type = soagen::const_row_type<planes>;

		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		enum class columns : size_type
		{
			value	 = 0,
			material = 1,
			normal_x = 2,
			normal_y = 3,
			normal_z = 4,
			d		 = 5,
		};

		template <auto Column>
		static constexpr auto& column_name = soagen::detail::column_name<planes, static_cast<size_type>(Column)>::value;

	  private:
		table_type table_;

	  public:
		SOAGEN_NODISCARD_CTOR
		planes() = default;

		SOAGEN_NODISCARD_CTOR
		planes(planes&&) = default;

		planes& operator=(planes&&) = default;

		SOAGEN_NODISCARD_CTOR
		planes(const planes&) = default;

		planes& operator=(const planes&) = default;

		~planes() = default;

		SOAGEN_NODISCARD_CTOR
		constexpr explicit planes(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		SOAGEN_NODISCARD_CTOR
		constexpr explicit planes(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&() noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&&() noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator const table_type&() const noexcept
		{
			return table_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR									   //
		std::enable_if_t<sfinae, planes&> erase(size_type pos)	   //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(pos);
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR																 //
		std::enable_if_t<sfinae, soagen::optional<size_type>> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)				 //
		{
			return table_.unordered_erase(pos);
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> erase(iterator pos)	   //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<iterator>> unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)			   //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type>)		   //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<const_iterator>> unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)						   //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		template <auto A, auto B>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		planes& swap_columns() //
			noexcept(noexcept(std::declval<table_type&>()
								  .template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>()))
		{
			table_.template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>();
			return *this;
		}

		// ------ push_back() --------------------------------------------------------------------------

		SOAGEN_CPP20_CONSTEXPR
		planes& push_back(column_traits<0>::param_type value,
						  column_traits<1>::param_type material,
						  column_traits<2>::param_type normal_x,
						  column_traits<3>::param_type normal_y,
						  column_traits<4>::param_type normal_z,
						  column_traits<5>::param_type d)			 //
			noexcept(table_traits::push_back_is_nothrow<table_type>) //
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(value),
								static_cast<column_traits<1>::param_forward_type>(material),
								static_cast<column_traits<2>::param_forward_type>(normal_x),
								static_cast<column_traits<3>::param_forward_type>(normal_y),
								static_cast<column_traits<4>::param_forward_type>(normal_z),
								static_cast<column_traits<5>::param_forward_type>(d));
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::rvalues_are_distinct)
		SOAGEN_CPP20_CONSTEXPR
		planes& push_back(column_traits<0>::rvalue_type value,
						  column_traits<1>::rvalue_type material,
						  column_traits<2>::rvalue_type normal_x,
						  column_traits<3>::rvalue_type normal_y,
						  column_traits<4>::rvalue_type normal_z,
						  column_traits<5>::rvalue_type d)					//
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type>) //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(value),
								static_cast<column_traits<1>::rvalue_forward_type>(material),
								static_cast<column_traits<2>::rvalue_forward_type>(normal_x),
								static_cast<column_traits<3>::rvalue_forward_type>(normal_y),
								static_cast<column_traits<4>::rvalue_forward_type>(normal_z),
								static_cast<column_traits<5>::rvalue_forward_type>(d));
			return *this;
		}

		// ------ emplace_back() -----------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE(
			(table_traits::row_constructible_from<Value&&, Material&&, NormalX&&, NormalY&&, NormalZ&&, D&&>), //
			typename Value,
			typename Material,
			typename NormalX,
			typename NormalY,
			typename NormalZ,
			typename D) //
		SOAGEN_CPP20_CONSTEXPR
		planes& emplace_back(Value&& value,
							 Material&& material,
							 NormalX&& normal_x,
							 NormalY&& normal_y,
							 NormalZ&& normal_z,
							 D&& d) //
			noexcept(
				table_traits::
					emplace_back_is_nothrow<table_type, Value&&, Material&&, NormalX&&, NormalY&&, NormalZ&&, D&&>) //
		{
			table_.emplace_back(static_cast<Value&&>(value),
								static_cast<Material&&>(material),
								static_cast<NormalX&&>(normal_x),
								static_cast<NormalY&&>(normal_y),
								static_cast<NormalZ&&>(normal_z),
								static_cast<D&&>(d));
			return *this;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(table_traits::row_constructible_from<Tuple>, typename Tuple)
		SOAGEN_CPP20_CONSTEXPR
		planes& emplace_back(Tuple&& tuple_)									 //
			noexcept(table_traits::emplace_back_is_nothrow<table_type, Tuple&&>) //
		{
			table_.emplace_back(static_cast<Tuple&&>(tuple_));
			return *this;
		}

	  private:
		static constexpr bool can_insert_ =
			table_traits::all_move_or_copy_constructible && table_traits::all_move_or_copy_assignable;

		static constexpr bool can_insert_rvalues_ = can_insert_ && table_traits::rvalues_are_distinct;

	  public:
		// ------ insert(size_type) --------------------------------------------------------------------

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, planes&> insert(size_type index_,
												 column_traits<0>::param_type value,
												 column_traits<1>::param_type material,
												 column_traits<2>::param_type normal_x,
												 column_traits<3>::param_type normal_y,
												 column_traits<4>::param_type normal_z,
												 column_traits<5>::param_type d) //
			noexcept(table_traits::insert_is_nothrow<table_type>)				 //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(normal_x),
						   static_cast<column_traits<3>::param_forward_type>(normal_y),
						   static_cast<column_traits<4>::param_forward_type>(normal_z),
						   static_cast<column_traits<5>::param_forward_type>(d));
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		planes& insert(std::enable_if_t<sfinae, size_type> index_,
					   column_traits<0>::rvalue_type value,
					   column_traits<1>::rvalue_type material,
					   column_traits<2>::rvalue_type normal_x,
					   column_traits<3>::rvalue_type normal_y,
					   column_traits<4>::rvalue_type normal_z,
					   column_traits<5>::rvalue_type d)			  //
			noexcept(table_traits::insert_is_nothrow<table_type>) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(normal_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(normal_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(normal_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(d));
			return *this;
		}

		// ------ insert(iterator) ---------------------------------------------------------------------

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> insert(iterator iter_,
												  column_traits<0>::param_type value,
												  column_traits<1>::param_type material,
												  column_traits<2>::param_type normal_x,
												  column_traits<3>::param_type normal_y,
												  column_traits<4>::param_type normal_z,
												  column_traits<5>::param_type d) //
			noexcept(table_traits::insert_is_nothrow<table_type>)				  //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(normal_x),
						   static_cast<column_traits<3>::param_forward_type>(normal_y),
						   static_cast<column_traits<4>::param_forward_type>(normal_z),
						   static_cast<column_traits<5>::param_forward_type>(d));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> insert(const_iterator iter_,
														column_traits<0>::param_type value,
														column_traits<1>::param_type material,
														column_traits<2>::param_type normal_x,
														column_traits<3>::param_type normal_y,
														column_traits<4>::param_type normal_z,
														column_traits<5>::param_type d) //
			noexcept(table_traits::insert_is_nothrow<table_type>)						//
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(normal_x),
						   static_cast<column_traits<3>::param_forward_type>(normal_y),
						   static_cast<column_traits<4>::param_forward_type>(normal_z),
						   static_cast<column_traits<5>::param_forward_type>(d));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(std::enable_if_t<sfinae, iterator> iter_,
						column_traits<0>::rvalue_type value,
						column_traits<1>::rvalue_type material,
						column_traits<2>::rvalue_type normal_x,
						column_traits<3>::rvalue_type normal_y,
						column_traits<4>::rvalue_type normal_z,
						column_traits<5>::rvalue_type d)		  //
			noexcept(table_traits::insert_is_nothrow<table_type>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(normal_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(normal_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(normal_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(d));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(std::enable_if_t<sfinae, const_iterator> iter_,
							  column_traits<0>::rvalue_type value,
							  column_traits<1>::rvalue_type material,
							  column_traits<2>::rvalue_type normal_x,
							  column_traits<3>::rvalue_type normal_y,
							  column_traits<4>::rvalue_type normal_z,
							  column_traits<5>::rvalue_type d)	  //
			noexcept(table_traits::insert_is_nothrow<table_type>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(normal_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(normal_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(normal_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(d));
			return iter_;
		}

		// ------ emplace(size_type) -------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE(
			sfinae,
			typename Value,
			typename Material,
			typename NormalX,
			typename NormalY,
			typename NormalZ,
			typename D,
			bool sfinae =
				table_traits::row_constructible_from<Value&&, Material&&, NormalX&&, NormalY&&, NormalZ&&, D&&>
				&& can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, planes&> emplace(size_type index_,
												  Value&& value,
												  Material&& material,
												  NormalX&& normal_x,
												  NormalY&& normal_y,
												  NormalZ&& normal_z,
												  D&& d) //
			noexcept(table_traits::
						 emplace_is_nothrow<table_type, Value&&, Material&&, NormalX&&, NormalY&&, NormalZ&&, D&&>) //
		{
			table_.emplace(index_,
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<NormalX&&>(normal_x),
						   static_cast<NormalY&&>(normal_y),
						   static_cast<NormalZ&&>(normal_z),
						   static_cast<D&&>(d));
			return *this;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		planes& emplace(std::enable_if_t<sfinae, size_type> index_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)			//
		{
			table_.emplace(index_, static_cast<Tuple&&>(tuple_));
			return *this;
		}

		// ------ emplace(iterator) --------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE(
			sfinae,
			typename Value,
			typename Material,
			typename NormalX,
			typename NormalY,
			typename NormalZ,
			typename D,
			bool sfinae =
				table_traits::row_constructible_from<Value&&, Material&&, NormalX&&, NormalY&&, NormalZ&&, D&&>
				&& can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> emplace(iterator iter_,
												   Value&& value,
												   Material&& material,
												   NormalX&& normal_x,
												   NormalY&& normal_y,
												   NormalZ&& normal_z,
												   D&& d) //
			noexcept(table_traits::
						 emplace_is_nothrow<table_type, Value&&, Material&&, NormalX&&, NormalY&&, NormalZ&&, D&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<NormalX&&>(normal_x),
						   static_cast<NormalY&&>(normal_y),
						   static_cast<NormalZ&&>(normal_z),
						   static_cast<D&&>(d));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		iterator emplace(std::enable_if_t<sfinae, iterator> iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)		   //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(
			sfinae,
			typename Value,
			typename Material,
			typename NormalX,
			typename NormalY,
			typename NormalZ,
			typename D,
			bool sfinae =
				table_traits::row_constructible_from<Value&&, Material&&, NormalX&&, NormalY&&, NormalZ&&, D&&>
				&& can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> emplace(const_iterator iter_,
														 Value&& value,
														 Material&& material,
														 NormalX&& normal_x,
														 NormalY&& normal_y,
														 NormalZ&& normal_z,
														 D&& d) //
			noexcept(table_traits::
						 emplace_is_nothrow<table_type, Value&&, Material&&, NormalX&&, NormalY&&, NormalZ&&, D&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<NormalX&&>(normal_x),
						   static_cast<NormalY&&>(normal_y),
						   static_cast<NormalZ&&>(normal_z),
						   static_cast<D&&>(d));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator emplace(std::enable_if_t<sfinae, const_iterator> iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)					   //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		template <auto Column>
		SOAGEN_COLUMN(planes, Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<planes, Column>>(table_.template column<Column>());
		}

		template <auto Column>
		SOAGEN_COLUMN(planes, Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<planes, Column>>(table_.template column<Column>());
		}
	};

	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<planes>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(planes& lhs, planes& rhs) //
		noexcept(soagen::has_nothrow_swap_member<planes>)
	{
		lhs.swap(rhs);
	}
}

//----------------------------------------------------------------------------------------------------------------------
// spheres
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	class SOAGEN_EMPTY_BASES spheres //
		: public soagen::mixins::size_and_capacity<spheres>,
		  public soagen::mixins::resizable<spheres>,
		  public soagen::mixins::equality_comparable<spheres>,
		  public soagen::mixins::less_than_comparable<spheres>,
		  public soagen::mixins::data_ptr<spheres>,
		  public soagen::mixins::columns<spheres>,
		  public soagen::mixins::rows<spheres>,
		  public soagen::mixins::iterators<spheres>,
		  public soagen::mixins::spans<spheres>,
		  public soagen::mixins::swappable<spheres>
	{
	  public:
		using size_type = std::size_t;

		using difference_type = std::ptrdiff_t;

		using allocator_type = soagen::allocator_type<spheres>;

		using table_type = soagen::table_type<spheres>;

		using table_traits = soagen::table_traits_type<spheres>;

		static constexpr size_type column_count = table_traits::column_count;

		template <auto Column>
		using column_traits = typename table_traits::template column<static_cast<size_type>(Column)>;

		template <auto Column>
		using column_type = typename column_traits<static_cast<size_type>(Column)>::value_type;

		using iterator = soagen::iterator_type<spheres>;

		using rvalue_iterator = soagen::rvalue_iterator_type<spheres>;

		using const_iterator = soagen::const_iterator_type<spheres>;

		using span_type = soagen::span_type<spheres>;

		using rvalue_span_type = soagen::rvalue_span_type<spheres>;

		using const_span_type = soagen::const_span_type<spheres>;

		using row_type = soagen::row_type<spheres>;

		using rvalue_row_type = soagen::rvalue_row_type<spheres>;

		using const_row_type = soagen::const_row_type<spheres>;

		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		enum class columns : size_type
		{
			value	 = 0,
			material = 1,
			center_x = 2,
			center_y = 3,
			center_z = 4,
			radius	 = 5,
		};

		template <auto Column>
		static constexpr auto& column_name =
			soagen::detail::column_name<spheres, static_cast<size_type>(Column)>::value;

	  private:
		table_type table_;

	  public:
		SOAGEN_NODISCARD_CTOR
		spheres() = default;

		SOAGEN_NODISCARD_CTOR
		spheres(spheres&&) = default;

		spheres& operator=(spheres&&) = default;

		SOAGEN_NODISCARD_CTOR
		spheres(const spheres&) = default;

		spheres& operator=(const spheres&) = default;

		~spheres() = default;

		SOAGEN_NODISCARD_CTOR
		constexpr explicit spheres(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		SOAGEN_NODISCARD_CTOR
		constexpr explicit spheres(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&() noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&&() noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator const table_type&() const noexcept
		{
			return table_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR									   //
		std::enable_if_t<sfinae, spheres&> erase(size_type pos)	   //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(pos);
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR																 //
		std::enable_if_t<sfinae, soagen::optional<size_type>> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)				 //
		{
			return table_.unordered_erase(pos);
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> erase(iterator pos)	   //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<iterator>> unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)			   //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type>)		   //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<const_iterator>> unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)						   //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		template <auto A, auto B>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& swap_columns() //
			noexcept(noexcept(std::declval<table_type&>()
								  .template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>()))
		{
			table_.template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>();
			return *this;
		}

		// ------ push_back() --------------------------------------------------------------------------

		SOAGEN_CPP20_CONSTEXPR
		spheres& push_back(column_traits<0>::param_type value,
						   column_traits<1>::param_type material,
						   column_traits<2>::param_type center_x,
						   column_traits<3>::param_type center_y,
						   column_traits<4>::param_type center_z,
						   column_traits<5>::param_type radius)		 //
			noexcept(table_traits::push_back_is_nothrow<table_type>) //
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(value),
								static_cast<column_traits<1>::param_forward_type>(material),
								static_cast<column_traits<2>::param_forward_type>(center_x),
								static_cast<column_traits<3>::param_forward_type>(center_y),
								static_cast<column_traits<4>::param_forward_type>(center_z),
								static_cast<column_traits<5>::param_forward_type>(radius));
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::rvalues_are_distinct)
		SOAGEN_CPP20_CONSTEXPR
		spheres& push_back(column_traits<0>::rvalue_type value,
						   column_traits<1>::rvalue_type material,
						   column_traits<2>::rvalue_type center_x,
						   column_traits<3>::rvalue_type center_y,
						   column_traits<4>::rvalue_type center_z,
						   column_traits<5>::rvalue_type radius)			//
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type>) //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(value),
								static_cast<column_traits<1>::rvalue_forward_type>(material),
								static_cast<column_traits<2>::rvalue_forward_type>(center_x),
								static_cast<column_traits<3>::rvalue_forward_type>(center_y),
								static_cast<column_traits<4>::rvalue_forward_type>(center_z),
								static_cast<column_traits<5>::rvalue_forward_type>(radius));
			return *this;
		}

		// ------ emplace_back() -----------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE(
			(table_traits::row_constructible_from<Value&&, Material&&, CenterX&&, CenterY&&, CenterZ&&, Radius&&>), //
			typename Value,
			typename Material,
			typename CenterX,
			typename CenterY,
			typename CenterZ,
			typename Radius) //
		SOAGEN_CPP20_CONSTEXPR
		spheres& emplace_back(Value&& value,
							  Material&& material,
							  CenterX&& center_x,
							  CenterY&& center_y,
							  CenterZ&& center_z,
							  Radius&& radius) //
			noexcept(table_traits::emplace_back_is_nothrow<table_type,
														   Value&&,
														   Material&&,
														   CenterX&&,
														   CenterY&&,
														   CenterZ&&,
														   Radius&&>) //
		{
			table_.emplace_back(static_cast<Value&&>(value),
								static_cast<Material&&>(material),
								static_cast<CenterX&&>(center_x),
								static_cast<CenterY&&>(center_y),
								static_cast<CenterZ&&>(center_z),
								static_cast<Radius&&>(radius));
			return *this;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(table_traits::row_constructible_from<Tuple>, typename Tuple)
		SOAGEN_CPP20_CONSTEXPR
		spheres& emplace_back(Tuple&& tuple_)									 //
			noexcept(table_traits::emplace_back_is_nothrow<table_type, Tuple&&>) //
		{
			table_.emplace_back(static_cast<Tuple&&>(tuple_));
			return *this;
		}

	  private:
		static constexpr bool can_insert_ =
			table_traits::all_move_or_copy_constructible && table_traits::all_move_or_copy_assignable;

		static constexpr bool can_insert_rvalues_ = can_insert_ && table_traits::rvalues_are_distinct;

	  public:
		// ------ insert(size_type) --------------------------------------------------------------------

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, spheres&> insert(size_type index_,
												  column_traits<0>::param_type value,
												  column_traits<1>::param_type material,
												  column_traits<2>::param_type center_x,
												  column_traits<3>::param_type center_y,
												  column_traits<4>::param_type center_z,
												  column_traits<5>::param_type radius) //
			noexcept(table_traits::insert_is_nothrow<table_type>)					   //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(center_x),
						   static_cast<column_traits<3>::param_forward_type>(center_y),
						   static_cast<column_traits<4>::param_forward_type>(center_z),
						   static_cast<column_traits<5>::param_forward_type>(radius));
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		spheres& insert(std::enable_if_t<sfinae, size_type> index_,
						column_traits<0>::rvalue_type value,
						column_traits<1>::rvalue_type material,
						column_traits<2>::rvalue_type center_x,
						column_traits<3>::rvalue_type center_y,
						column_traits<4>::rvalue_type center_z,
						column_traits<5>::rvalue_type radius)	  //
			noexcept(table_traits::insert_is_nothrow<table_type>) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(radius));
			return *this;
		}

		// ------ insert(iterator) ---------------------------------------------------------------------

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> insert(iterator iter_,
												  column_traits<0>::param_type value,
												  column_traits<1>::param_type material,
												  column_traits<2>::param_type center_x,
												  column_traits<3>::param_type center_y,
												  column_traits<4>::param_type center_z,
												  column_traits<5>::param_type radius) //
			noexcept(table_traits::insert_is_nothrow<table_type>)					   //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(center_x),
						   static_cast<column_traits<3>::param_forward_type>(center_y),
						   static_cast<column_traits<4>::param_forward_type>(center_z),
						   static_cast<column_traits<5>::param_forward_type>(radius));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> insert(const_iterator iter_,
														column_traits<0>::param_type value,
														column_traits<1>::param_type material,
														column_traits<2>::param_type center_x,
														column_traits<3>::param_type center_y,
														column_traits<4>::param_type center_z,
														column_traits<5>::param_type radius) //
			noexcept(table_traits::insert_is_nothrow<table_type>)							 //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(center_x),
						   static_cast<column_traits<3>::param_forward_type>(center_y),
						   static_cast<column_traits<4>::param_forward_type>(center_z),
						   static_cast<column_traits<5>::param_forward_type>(radius));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(std::enable_if_t<sfinae, iterator> iter_,
						column_traits<0>::rvalue_type value,
						column_traits<1>::rvalue_type material,
						column_traits<2>::rvalue_type center_x,
						column_traits<3>::rvalue_type center_y,
						column_traits<4>::rvalue_type center_z,
						column_traits<5>::rvalue_type radius)	  //
			noexcept(table_traits::insert_is_nothrow<table_type>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(radius));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(std::enable_if_t<sfinae, const_iterator> iter_,
							  column_traits<0>::rvalue_type value,
							  column_traits<1>::rvalue_type material,
							  column_traits<2>::rvalue_type center_x,
							  column_traits<3>::rvalue_type center_y,
							  column_traits<4>::rvalue_type center_z,
							  column_traits<5>::rvalue_type radius) //
			noexcept(table_traits::insert_is_nothrow<table_type>)	//
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(radius));
			return iter_;
		}

		// ------ emplace(size_type) -------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE(
			sfinae,
			typename Value,
			typename Material,
			typename CenterX,
			typename CenterY,
			typename CenterZ,
			typename Radius,
			bool sfinae =
				table_traits::row_constructible_from<Value&&, Material&&, CenterX&&, CenterY&&, CenterZ&&, Radius&&>
				&& can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, spheres&> emplace(size_type index_,
												   Value&& value,
												   Material&& material,
												   CenterX&& center_x,
												   CenterY&& center_y,
												   CenterZ&& center_z,
												   Radius&& radius) //
			noexcept(
				table_traits::
					emplace_is_nothrow<table_type, Value&&, Material&&, CenterX&&, CenterY&&, CenterZ&&, Radius&&>) //
		{
			table_.emplace(index_,
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<Radius&&>(radius));
			return *this;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		spheres& emplace(std::enable_if_t<sfinae, size_type> index_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)			 //
		{
			table_.emplace(index_, static_cast<Tuple&&>(tuple_));
			return *this;
		}

		// ------ emplace(iterator) --------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE(
			sfinae,
			typename Value,
			typename Material,
			typename CenterX,
			typename CenterY,
			typename CenterZ,
			typename Radius,
			bool sfinae =
				table_traits::row_constructible_from<Value&&, Material&&, CenterX&&, CenterY&&, CenterZ&&, Radius&&>
				&& can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> emplace(iterator iter_,
												   Value&& value,
												   Material&& material,
												   CenterX&& center_x,
												   CenterY&& center_y,
												   CenterZ&& center_z,
												   Radius&& radius) //
			noexcept(
				table_traits::
					emplace_is_nothrow<table_type, Value&&, Material&&, CenterX&&, CenterY&&, CenterZ&&, Radius&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<Radius&&>(radius));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		iterator emplace(std::enable_if_t<sfinae, iterator> iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)		   //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(
			sfinae,
			typename Value,
			typename Material,
			typename CenterX,
			typename CenterY,
			typename CenterZ,
			typename Radius,
			bool sfinae =
				table_traits::row_constructible_from<Value&&, Material&&, CenterX&&, CenterY&&, CenterZ&&, Radius&&>
				&& can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> emplace(const_iterator iter_,
														 Value&& value,
														 Material&& material,
														 CenterX&& center_x,
														 CenterY&& center_y,
														 CenterZ&& center_z,
														 Radius&& radius) //
			noexcept(
				table_traits::
					emplace_is_nothrow<table_type, Value&&, Material&&, CenterX&&, CenterY&&, CenterZ&&, Radius&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<Radius&&>(radius));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator emplace(std::enable_if_t<sfinae, const_iterator> iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)					   //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		template <auto Column>
		SOAGEN_COLUMN(spheres, Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<spheres, Column>>(table_.template column<Column>());
		}

		template <auto Column>
		SOAGEN_COLUMN(spheres, Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<spheres, Column>>(table_.template column<Column>());
		}
	};

	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<spheres>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(spheres& lhs, spheres& rhs) //
		noexcept(soagen::has_nothrow_swap_member<spheres>)
	{
		lhs.swap(rhs);
	}
}

#if SOAGEN_MSVC_LIKE
	#pragma pop_macro("min")
	#pragma pop_macro("max")
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(off)
#endif
SOAGEN_POP_WARNINGS;
