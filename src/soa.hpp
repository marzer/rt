//----------------------------------------------------------------------------------------------------------------------
// This file was generated by soagen - do not modify it directly
// https://github.com/marzer/soagen
//----------------------------------------------------------------------------------------------------------------------
#pragma once

#include <soagen.hpp>

SOAGEN_DISABLE_WARNINGS;
#include <tuple>
SOAGEN_ENABLE_WARNINGS;

SOAGEN_PUSH_WARNINGS;
SOAGEN_DISABLE_SPAM_WARNINGS;
#if SOAGEN_MSVC
	#pragma inline_recursion(on)
#endif
#if SOAGEN_MSVC_LIKE
	#pragma push_macro("min")
	#pragma push_macro("max")
	#undef min
	#undef max
#endif

//----------------------------------------------------------------------------------------------------------------------
// forward declarations
//----------------------------------------------------------------------------------------------------------------------
namespace rt
{
	class spheres;

	class vertices;
}

//----------------------------------------------------------------------------------------------------------------------
// spheres
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	class spheres
	{
	  private:
		template <typename ValueType,
				  typename ParamType = soagen::param_type<ValueType>,
				  size_t Align		 = alignof(ValueType)>
		using make_col = soagen::column_traits<ValueType, ParamType, soagen::max(Align, alignof(ValueType))>;

	  public:
		using size_type		  = std::size_t;
		using difference_type = std::ptrdiff_t;
		using allocator_type  = soagen::allocator;

		using table_traits = soagen::table_traits<
			/* center_x */ make_col<float, soagen::param_type<float>, 32>,
			/* center_y */ make_col<float, soagen::param_type<float>, 32>,
			/* center_z */ make_col<float, soagen::param_type<float>, 32>,
			/*	 radius */ make_col<float, soagen::param_type<float>, 32>>;

		template <size_type I>
		using column_traits = typename table_traits::template column<I>;

		template <size_type I>
		using column_type = typename column_traits<I>::value_type;

		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		struct column_indices
		{
			static constexpr size_type center_x = 0;
			static constexpr size_type center_y = 1;
			static constexpr size_type center_z = 2;
			static constexpr size_type radius	= 3;
		};

	  private:
		// clang-format off
			template <size_type> struct column_name_{};
			template <> struct column_name_<0>{  static constexpr auto value = "center_x"; };
			template <> struct column_name_<1>{  static constexpr auto value = "center_y"; };
			template <> struct column_name_<2>{  static constexpr auto value = "center_z"; };
			template <> struct column_name_<3>{  static constexpr auto value = "radius"; };
		// clang-format on

	  public:
		template <size_type I>
		static constexpr auto& column_name = column_name_<I>::value;

		static constexpr std::tuple<int, float, const char*> kek = { 1, 2.0, "3" };

	  private:
		using table_type = soagen::table<table_traits, allocator_type>;
		table_type table_;

	  public:
		SOAGEN_NODISCARD_CTOR
		spheres() = default;

		SOAGEN_NODISCARD_CTOR
		spheres(const spheres&) = default;

		SOAGEN_NODISCARD_CTOR
		spheres(spheres&&) = default;

		spheres& operator=(const spheres&) = default;

		spheres& operator=(spheres&&) = default;

		~spheres() = default;

		SOAGEN_NODISCARD_CTOR
		constexpr explicit spheres(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		SOAGEN_NODISCARD_CTOR
		constexpr explicit spheres(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr std::byte* data() noexcept
		{
			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, 0>>(
				table_.data());
		}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const std::byte* data() const noexcept
		{
			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, 0>>(
				table_.data());
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void clear() noexcept
		{
			return table_.clear();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void reserve(size_type new_cap) noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_resize_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void resize(size_type new_size) noexcept(soagen::has_nothrow_resize_member<table_type, size_type>)
		{
			table_.resize(new_size);
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void shrink_to_fit() noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void pop_back(size_type num = 1) noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void erase(size_type pos) noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void unordered_erase(size_type pos) noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			table_.unordered_erase(pos);
		}

		SOAGEN_INLINE_GETTER
		constexpr allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		template <size_t I>
		SOAGEN_ALIGNED_COLUMN(I)
		column_type<I>* column() noexcept
		{
			static_assert(I < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, I>>(
				table_.template column<I>());
		}

		template <size_t I>
		SOAGEN_ALIGNED_COLUMN(I)
		std::add_const_t<column_type<I>>* column() const noexcept
		{
			static_assert(I < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, I>>(
				table_.template column<I>());
		}

		SOAGEN_ALIGNED_COLUMN(0)
		float* center_x() noexcept
		{
			return column<0>();
		}

		SOAGEN_ALIGNED_COLUMN(0)
		const float* center_x() const noexcept
		{
			return column<0>();
		}

		SOAGEN_ALIGNED_COLUMN(1)
		float* center_y() noexcept
		{
			return column<1>();
		}

		SOAGEN_ALIGNED_COLUMN(1)
		const float* center_y() const noexcept
		{
			return column<1>();
		}

		SOAGEN_ALIGNED_COLUMN(2)
		float* center_z() noexcept
		{
			return column<2>();
		}

		SOAGEN_ALIGNED_COLUMN(2)
		const float* center_z() const noexcept
		{
			return column<2>();
		}

		SOAGEN_ALIGNED_COLUMN(3)
		float* radius() noexcept
		{
			return column<3>();
		}

		SOAGEN_ALIGNED_COLUMN(3)
		const float* radius() const noexcept
		{
			return column<3>();
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		constexpr void swap(spheres& other) noexcept(soagen::has_nothrow_swap_member<table_type>)
		{
			table_.swap(other.table_);
		}
	};

	SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<spheres>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(spheres& lhs, spheres& rhs) //
		noexcept(soagen::has_nothrow_swap_member<spheres>)
	{
		lhs.swap(rhs);
	}
}

//----------------------------------------------------------------------------------------------------------------------
// vertices
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	class vertices
	{
	  private:
		template <typename ValueType,
				  typename ParamType = soagen::param_type<ValueType>,
				  size_t Align		 = alignof(ValueType)>
		using make_col = soagen::column_traits<ValueType, ParamType, soagen::max(Align, alignof(ValueType))>;

	  public:
		using size_type		  = std::size_t;
		using difference_type = std::ptrdiff_t;
		using allocator_type  = soagen::allocator;

		using table_traits = soagen::table_traits<
			/* position_x */ make_col<float, soagen::param_type<float>, 32>,
			/* position_y */ make_col<float, soagen::param_type<float>, 32>,
			/* position_z */ make_col<float, soagen::param_type<float>, 32>,
			/*	 normal_x */ make_col<float, soagen::param_type<float>, 32>,
			/*	 normal_y */ make_col<float, soagen::param_type<float>, 32>,
			/*	 normal_z */ make_col<float, soagen::param_type<float>, 32>>;

		template <size_type I>
		using column_traits = typename table_traits::template column<I>;

		template <size_type I>
		using column_type = typename column_traits<I>::value_type;

		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		struct column_indices
		{
			static constexpr size_type position_x = 0;
			static constexpr size_type position_y = 1;
			static constexpr size_type position_z = 2;
			static constexpr size_type normal_x	  = 3;
			static constexpr size_type normal_y	  = 4;
			static constexpr size_type normal_z	  = 5;
		};

	  private:
		// clang-format off
			template <size_type> struct column_name_{};
			template <> struct column_name_<0>{  static constexpr auto value = "position_x"; };
			template <> struct column_name_<1>{  static constexpr auto value = "position_y"; };
			template <> struct column_name_<2>{  static constexpr auto value = "position_z"; };
			template <> struct column_name_<3>{  static constexpr auto value = "normal_x"; };
			template <> struct column_name_<4>{  static constexpr auto value = "normal_y"; };
			template <> struct column_name_<5>{  static constexpr auto value = "normal_z"; };
		// clang-format on

	  public:
		template <size_type I>
		static constexpr auto& column_name = column_name_<I>::value;

	  private:
		using table_type = soagen::table<table_traits, allocator_type>;
		table_type table_;

	  public:
		SOAGEN_NODISCARD_CTOR
		vertices() = default;

		SOAGEN_NODISCARD_CTOR
		vertices(const vertices&) = default;

		SOAGEN_NODISCARD_CTOR
		vertices(vertices&&) = default;

		vertices& operator=(const vertices&) = default;

		vertices& operator=(vertices&&) = default;

		~vertices() = default;

		SOAGEN_NODISCARD_CTOR
		constexpr explicit vertices(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		SOAGEN_NODISCARD_CTOR
		constexpr explicit vertices(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr std::byte* data() noexcept
		{
			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, 0>>(
				table_.data());
		}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const std::byte* data() const noexcept
		{
			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, 0>>(
				table_.data());
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void clear() noexcept
		{
			return table_.clear();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void reserve(size_type new_cap) noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_resize_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void resize(size_type new_size) noexcept(soagen::has_nothrow_resize_member<table_type, size_type>)
		{
			table_.resize(new_size);
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void shrink_to_fit() noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void pop_back(size_type num = 1) noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void erase(size_type pos) noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void unordered_erase(size_type pos) noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			table_.unordered_erase(pos);
		}

		SOAGEN_INLINE_GETTER
		constexpr allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		template <size_t I>
		SOAGEN_ALIGNED_COLUMN(I)
		column_type<I>* column() noexcept
		{
			static_assert(I < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, I>>(
				table_.template column<I>());
		}

		template <size_t I>
		SOAGEN_ALIGNED_COLUMN(I)
		std::add_const_t<column_type<I>>* column() const noexcept
		{
			static_assert(I < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, I>>(
				table_.template column<I>());
		}

		SOAGEN_ALIGNED_COLUMN(0)
		float* position_x() noexcept
		{
			return column<0>();
		}

		SOAGEN_ALIGNED_COLUMN(0)
		const float* position_x() const noexcept
		{
			return column<0>();
		}

		SOAGEN_ALIGNED_COLUMN(1)
		float* position_y() noexcept
		{
			return column<1>();
		}

		SOAGEN_ALIGNED_COLUMN(1)
		const float* position_y() const noexcept
		{
			return column<1>();
		}

		SOAGEN_ALIGNED_COLUMN(2)
		float* position_z() noexcept
		{
			return column<2>();
		}

		SOAGEN_ALIGNED_COLUMN(2)
		const float* position_z() const noexcept
		{
			return column<2>();
		}

		SOAGEN_ALIGNED_COLUMN(3)
		float* normal_x() noexcept
		{
			return column<3>();
		}

		SOAGEN_ALIGNED_COLUMN(3)
		const float* normal_x() const noexcept
		{
			return column<3>();
		}

		SOAGEN_ALIGNED_COLUMN(4)
		float* normal_y() noexcept
		{
			return column<4>();
		}

		SOAGEN_ALIGNED_COLUMN(4)
		const float* normal_y() const noexcept
		{
			return column<4>();
		}

		SOAGEN_ALIGNED_COLUMN(5)
		float* normal_z() noexcept
		{
			return column<5>();
		}

		SOAGEN_ALIGNED_COLUMN(5)
		const float* normal_z() const noexcept
		{
			return column<5>();
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		constexpr void swap(vertices& other) noexcept(soagen::has_nothrow_swap_member<table_type>)
		{
			table_.swap(other.table_);
		}
	};

	SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<vertices>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(vertices& lhs, vertices& rhs) //
		noexcept(soagen::has_nothrow_swap_member<vertices>)
	{
		lhs.swap(rhs);
	}
}

//----------------------------------------------------------------------------------------------------------------------
// template specializations
//----------------------------------------------------------------------------------------------------------------------

namespace soagen
{
	template <>
	inline constexpr bool is_soa<rt::spheres> = true;

	template <>
	inline constexpr bool is_soa<rt::vertices> = true;
}

#if SOAGEN_MSVC_LIKE
	#pragma pop_macro("min")
	#pragma pop_macro("max")
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(off)
#endif
SOAGEN_POP_WARNINGS;
