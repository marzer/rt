//----------------------------------------------------------------------------------------------------------------------
// This file was generated by soagen v0.1.0 - do not modify it directly
// https://marzer.github.io/soagen
//----------------------------------------------------------------------------------------------------------------------
#pragma once

#include "colour.hpp"
#include "common.hpp"

#include <soagen.hpp>
#if SOAGEN_VERSION_MAJOR != 0 || SOAGEN_VERSION_MINOR < 1
	#error soagen version mismatch - expected v0.1.X
#endif

SOAGEN_DISABLE_WARNINGS;
#if SOAGEN_HAS_EXCEPTIONS
	#include <stdexcept>
#endif
SOAGEN_ENABLE_WARNINGS;

SOAGEN_PUSH_WARNINGS;
SOAGEN_DISABLE_SPAM_WARNINGS;
#if SOAGEN_CLANG >= 16
	#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(on)
#endif
#if SOAGEN_MSVC_LIKE
	#pragma push_macro("min")
	#pragma push_macro("max")
	#undef min
	#undef max
#endif

//----------------------------------------------------------------------------------------------------------------------
// forward declarations + soagen internal boilerplate
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	class boxes;
	class materials;
	class planes;
	class spheres;
}

namespace soagen
{
	template <>
	inline constexpr bool is_soa<rt::boxes> = true;

	template <>
	inline constexpr bool is_soa<rt::materials> = true;

	template <>
	inline constexpr bool is_soa<rt::planes> = true;

	template <>
	inline constexpr bool is_soa<rt::spheres> = true;
}

namespace soagen::detail
{
#ifndef SOAGEN_NAME_center_x
	#define SOAGEN_NAME_center_x
	SOAGEN_MAKE_NAME(center_x);
#endif

#ifndef SOAGEN_NAME_center_y
	#define SOAGEN_NAME_center_y
	SOAGEN_MAKE_NAME(center_y);
#endif

#ifndef SOAGEN_NAME_center_z
	#define SOAGEN_NAME_center_z
	SOAGEN_MAKE_NAME(center_z);
#endif

#ifndef SOAGEN_NAME_colour
	#define SOAGEN_NAME_colour
	SOAGEN_MAKE_NAME(colour);
#endif

#ifndef SOAGEN_NAME_d
	#define SOAGEN_NAME_d
	SOAGEN_MAKE_NAME(d);
#endif

#ifndef SOAGEN_NAME_extents_x
	#define SOAGEN_NAME_extents_x
	SOAGEN_MAKE_NAME(extents_x);
#endif

#ifndef SOAGEN_NAME_extents_y
	#define SOAGEN_NAME_extents_y
	SOAGEN_MAKE_NAME(extents_y);
#endif

#ifndef SOAGEN_NAME_extents_z
	#define SOAGEN_NAME_extents_z
	SOAGEN_MAKE_NAME(extents_z);
#endif

#ifndef SOAGEN_NAME_material
	#define SOAGEN_NAME_material
	SOAGEN_MAKE_NAME(material);
#endif

#ifndef SOAGEN_NAME_normal_x
	#define SOAGEN_NAME_normal_x
	SOAGEN_MAKE_NAME(normal_x);
#endif

#ifndef SOAGEN_NAME_normal_y
	#define SOAGEN_NAME_normal_y
	SOAGEN_MAKE_NAME(normal_y);
#endif

#ifndef SOAGEN_NAME_normal_z
	#define SOAGEN_NAME_normal_z
	SOAGEN_MAKE_NAME(normal_z);
#endif

#ifndef SOAGEN_NAME_radius
	#define SOAGEN_NAME_radius
	SOAGEN_MAKE_NAME(radius);
#endif

#ifndef SOAGEN_NAME_value
	#define SOAGEN_NAME_value
	SOAGEN_MAKE_NAME(value);
#endif

	template <>
	struct table_traits_type_<rt::boxes>
	{
		using type = table_traits<
			/*	   value */ make_column<rt::box>,
			/*	material */ make_column<size_t>,
			/*	center_x */ make_column<float, param_type<float>, 32>,
			/*	center_y */ make_column<float, param_type<float>, 32>,
			/*	center_z */ make_column<float, param_type<float>, 32>,
			/* extents_x */ make_column<float, param_type<float>, 32>,
			/* extents_y */ make_column<float, param_type<float>, 32>,
			/* extents_z */ make_column<float, param_type<float>, 32>>;
	};

	template <>
	struct allocator_type_<rt::boxes>
	{
		using type = soagen::allocator;
	};

	SOAGEN_MAKE_COL(rt::boxes, 0, value);
	SOAGEN_MAKE_COL(rt::boxes, 1, material);
	SOAGEN_MAKE_COL(rt::boxes, 2, center_x);
	SOAGEN_MAKE_COL(rt::boxes, 3, center_y);
	SOAGEN_MAKE_COL(rt::boxes, 4, center_z);
	SOAGEN_MAKE_COL(rt::boxes, 5, extents_x);
	SOAGEN_MAKE_COL(rt::boxes, 6, extents_y);
	SOAGEN_MAKE_COL(rt::boxes, 7, extents_z);

	template <>
	struct table_type_<rt::boxes>
	{
		using type = table<table_traits_type<rt::boxes>, soagen::allocator>;
	};

	template <>
	struct table_traits_type_<rt::materials>
	{
		using type = table_traits<
			/* colour */ make_column<rt::colour>>;
	};

	template <>
	struct allocator_type_<rt::materials>
	{
		using type = soagen::allocator;
	};

	SOAGEN_MAKE_COL(rt::materials, 0, colour);

	template <>
	struct table_type_<rt::materials>
	{
		using type = table<table_traits_type<rt::materials>, soagen::allocator>;
	};

	template <>
	struct table_traits_type_<rt::planes>
	{
		using type = table_traits<
			/*	  value */ make_column<rt::plane>,
			/* material */ make_column<size_t>,
			/* normal_x */ make_column<float, param_type<float>, 32>,
			/* normal_y */ make_column<float, param_type<float>, 32>,
			/* normal_z */ make_column<float, param_type<float>, 32>,
			/*		  d */ make_column<float, param_type<float>, 32>>;
	};

	template <>
	struct allocator_type_<rt::planes>
	{
		using type = soagen::allocator;
	};

	SOAGEN_MAKE_COL(rt::planes, 0, value);
	SOAGEN_MAKE_COL(rt::planes, 1, material);
	SOAGEN_MAKE_COL(rt::planes, 2, normal_x);
	SOAGEN_MAKE_COL(rt::planes, 3, normal_y);
	SOAGEN_MAKE_COL(rt::planes, 4, normal_z);
	SOAGEN_MAKE_COL(rt::planes, 5, d);

	template <>
	struct table_type_<rt::planes>
	{
		using type = table<table_traits_type<rt::planes>, soagen::allocator>;
	};

	template <>
	struct table_traits_type_<rt::spheres>
	{
		using type = table_traits<
			/*	  value */ make_column<rt::sphere>,
			/* material */ make_column<size_t>,
			/* center_x */ make_column<float, param_type<float>, 32>,
			/* center_y */ make_column<float, param_type<float>, 32>,
			/* center_z */ make_column<float, param_type<float>, 32>,
			/*	 radius */ make_column<float, param_type<float>, 32>>;
	};

	template <>
	struct allocator_type_<rt::spheres>
	{
		using type = soagen::allocator;
	};

	SOAGEN_MAKE_COL(rt::spheres, 0, value);
	SOAGEN_MAKE_COL(rt::spheres, 1, material);
	SOAGEN_MAKE_COL(rt::spheres, 2, center_x);
	SOAGEN_MAKE_COL(rt::spheres, 3, center_y);
	SOAGEN_MAKE_COL(rt::spheres, 4, center_z);
	SOAGEN_MAKE_COL(rt::spheres, 5, radius);

	template <>
	struct table_type_<rt::spheres>
	{
		using type = table<table_traits_type<rt::spheres>, soagen::allocator>;
	};
}

//----------------------------------------------------------------------------------------------------------------------
// boxes
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	class SOAGEN_EMPTY_BASES boxes //
		: public soagen::mixins::resizable<boxes>,
		  public soagen::mixins::equality_comparable<boxes>,
		  public soagen::mixins::less_than_comparable<boxes>,
		  public soagen::mixins::data_ptr<boxes>,
		  public soagen::mixins::const_data_ptr<boxes>,
		  public soagen::mixins::swappable<boxes>
	{
	  public:
		using size_type = std::size_t;

		using difference_type = std::ptrdiff_t;

		using allocator_type = soagen::allocator_type<boxes>;

		using table_type = soagen::table_type<boxes>;

		using table_traits = soagen::table_traits_type<boxes>;

		static constexpr size_t column_count = soagen::table_traits_type<boxes>::column_count;

		template <size_type Column>
		using column_traits = typename table_traits::template column<Column>;

		template <size_type Column>
		using column_type = typename column_traits<Column>::value_type;

		using iterator = soagen::iterator_type<boxes&>;

		using const_iterator = soagen::iterator_type<const boxes&>;

		using rvalue_iterator = soagen::iterator_type<boxes&&>;

		using row_type = soagen::row_type<boxes&>;

		using const_row_type = soagen::row_type<const boxes&>;

		using rvalue_row_type = soagen::row_type<boxes&&>;

		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		struct column_indices
		{
			static constexpr size_type value	 = 0;
			static constexpr size_type material	 = 1;
			static constexpr size_type center_x	 = 2;
			static constexpr size_type center_y	 = 3;
			static constexpr size_type center_z	 = 4;
			static constexpr size_type extents_x = 5;
			static constexpr size_type extents_y = 6;
			static constexpr size_type extents_z = 7;
		};

		template <size_type Column>
		static constexpr auto& column_name = soagen::detail::col_name_<boxes, Column>::value;

	  private:
		table_type table_;

	  public:
		SOAGEN_NODISCARD_CTOR
		boxes() = default;

		SOAGEN_NODISCARD_CTOR
		boxes(boxes&&) = default;

		boxes& operator=(boxes&&) = default;

		SOAGEN_NODISCARD_CTOR
		boxes(const boxes&) = default;

		boxes& operator=(const boxes&) = default;

		~boxes() = default;

		SOAGEN_NODISCARD_CTOR
		constexpr explicit boxes(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		SOAGEN_NODISCARD_CTOR
		constexpr explicit boxes(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type allocation_size() const noexcept
		{
			return table_.allocation_size();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& reserve(size_type new_cap) //
			noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
			return *this;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& shrink_to_fit() //
			noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
			return *this;
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& clear() noexcept
		{
			table_.clear();
			return *this;
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, boxes&> erase(size_type pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
			return *this;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<size_type>> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			return table_.unordered_erase(pos);
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> erase(iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<iterator>> unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<const_iterator>> unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& pop_back(size_type num = 1) //
			noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
			return *this;
		}

		SOAGEN_CPP20_CONSTEXPR
		boxes& push_back(column_traits<0>::param_type value,
						 column_traits<1>::param_type material,
						 column_traits<2>::param_type center_x,
						 column_traits<3>::param_type center_y,
						 column_traits<4>::param_type center_z,
						 column_traits<5>::param_type extents_x,
						 column_traits<6>::param_type extents_y,
						 column_traits<7>::param_type extents_z) //
			noexcept(table_traits::push_back_is_nothrow<table_type&>)
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(value),
								static_cast<column_traits<1>::param_forward_type>(material),
								static_cast<column_traits<2>::param_forward_type>(center_x),
								static_cast<column_traits<3>::param_forward_type>(center_y),
								static_cast<column_traits<4>::param_forward_type>(center_z),
								static_cast<column_traits<5>::param_forward_type>(extents_x),
								static_cast<column_traits<6>::param_forward_type>(extents_y),
								static_cast<column_traits<7>::param_forward_type>(extents_z));
			return *this;
		}

		template <bool sfinae = table_traits::rvalue_type_list_is_distinct>
		SOAGEN_CPP20_CONSTEXPR
		boxes& push_back(std::enable_if_t<sfinae, column_traits<0>::rvalue_type> value,
						 column_traits<1>::rvalue_type material,
						 column_traits<2>::rvalue_type center_x,
						 column_traits<3>::rvalue_type center_y,
						 column_traits<4>::rvalue_type center_z,
						 column_traits<5>::rvalue_type extents_x,
						 column_traits<6>::rvalue_type extents_y,
						 column_traits<7>::rvalue_type extents_z)			//
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct) //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(value),
								static_cast<column_traits<1>::rvalue_forward_type>(material),
								static_cast<column_traits<2>::rvalue_forward_type>(center_x),
								static_cast<column_traits<3>::rvalue_forward_type>(center_y),
								static_cast<column_traits<4>::rvalue_forward_type>(center_z),
								static_cast<column_traits<5>::rvalue_forward_type>(extents_x),
								static_cast<column_traits<6>::rvalue_forward_type>(extents_y),
								static_cast<column_traits<7>::rvalue_forward_type>(extents_z));
			return *this;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<soagen::is_soa<soagen::remove_cvref<Table>>, int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		boxes& push_back(const soagen::row<Table, Columns...>& row_)		 //
			noexcept(table_traits::row_push_back_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>) //
		{
			table_.emplace_back(row_);
			return *this;
		}

		template <typename Value,
				  typename Material,
				  typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename ExtentsX,
				  typename ExtentsY,
				  typename ExtentsZ>
		SOAGEN_CPP20_CONSTEXPR
		boxes& emplace_back(Value&& value,
							Material&& material,
							CenterX&& center_x,
							CenterY&& center_y,
							CenterZ&& center_z,
							ExtentsX&& extents_x,
							ExtentsY&& extents_y,
							ExtentsZ&& extents_z) //
			noexcept(table_traits::emplace_back_is_nothrow<table_type&,
														   Value&&,
														   Material&&,
														   CenterX&&,
														   CenterY&&,
														   CenterZ&&,
														   ExtentsX&&,
														   ExtentsY&&,
														   ExtentsZ&&>)
		{
			table_.emplace_back(static_cast<Value&&>(value),
								static_cast<Material&&>(material),
								static_cast<CenterX&&>(center_x),
								static_cast<CenterY&&>(center_y),
								static_cast<CenterZ&&>(center_z),
								static_cast<ExtentsX&&>(extents_x),
								static_cast<ExtentsY&&>(extents_y),
								static_cast<ExtentsZ&&>(extents_z));
			return *this;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, boxes&> insert(size_type index_,
												column_traits<0>::param_type value,
												column_traits<1>::param_type material,
												column_traits<2>::param_type center_x,
												column_traits<3>::param_type center_y,
												column_traits<4>::param_type center_z,
												column_traits<5>::param_type extents_x,
												column_traits<6>::param_type extents_y,
												column_traits<7>::param_type extents_z)					  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(center_x),
						   static_cast<column_traits<3>::param_forward_type>(center_y),
						   static_cast<column_traits<4>::param_forward_type>(center_z),
						   static_cast<column_traits<5>::param_forward_type>(extents_x),
						   static_cast<column_traits<6>::param_forward_type>(extents_y),
						   static_cast<column_traits<7>::param_forward_type>(extents_z));
			return *this;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> insert(iterator iter_,
												  column_traits<0>::param_type value,
												  column_traits<1>::param_type material,
												  column_traits<2>::param_type center_x,
												  column_traits<3>::param_type center_y,
												  column_traits<4>::param_type center_z,
												  column_traits<5>::param_type extents_x,
												  column_traits<6>::param_type extents_y,
												  column_traits<7>::param_type extents_z)				  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(center_x),
						   static_cast<column_traits<3>::param_forward_type>(center_y),
						   static_cast<column_traits<4>::param_forward_type>(center_z),
						   static_cast<column_traits<5>::param_forward_type>(extents_x),
						   static_cast<column_traits<6>::param_forward_type>(extents_y),
						   static_cast<column_traits<7>::param_forward_type>(extents_z));
			return iter_;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> insert(const_iterator iter_,
														column_traits<0>::param_type value,
														column_traits<1>::param_type material,
														column_traits<2>::param_type center_x,
														column_traits<3>::param_type center_y,
														column_traits<4>::param_type center_z,
														column_traits<5>::param_type extents_x,
														column_traits<6>::param_type extents_y,
														column_traits<7>::param_type extents_z)			  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(center_x),
						   static_cast<column_traits<3>::param_forward_type>(center_y),
						   static_cast<column_traits<4>::param_forward_type>(center_z),
						   static_cast<column_traits<5>::param_forward_type>(extents_x),
						   static_cast<column_traits<6>::param_forward_type>(extents_y),
						   static_cast<column_traits<7>::param_forward_type>(extents_z));
			return iter_;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		boxes& insert(std::enable_if_t<sfinae, size_type> index_,
					  column_traits<0>::rvalue_type value,
					  column_traits<1>::rvalue_type material,
					  column_traits<2>::rvalue_type center_x,
					  column_traits<3>::rvalue_type center_y,
					  column_traits<4>::rvalue_type center_z,
					  column_traits<5>::rvalue_type extents_x,
					  column_traits<6>::rvalue_type extents_y,
					  column_traits<7>::rvalue_type extents_z) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(extents_x),
						   static_cast<column_traits<6>::rvalue_forward_type>(extents_y),
						   static_cast<column_traits<7>::rvalue_forward_type>(extents_z));
			return *this;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(std::enable_if_t<sfinae, iterator> iter_,
						column_traits<0>::rvalue_type value,
						column_traits<1>::rvalue_type material,
						column_traits<2>::rvalue_type center_x,
						column_traits<3>::rvalue_type center_y,
						column_traits<4>::rvalue_type center_z,
						column_traits<5>::rvalue_type extents_x,
						column_traits<6>::rvalue_type extents_y,
						column_traits<7>::rvalue_type extents_z) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(extents_x),
						   static_cast<column_traits<6>::rvalue_forward_type>(extents_y),
						   static_cast<column_traits<7>::rvalue_forward_type>(extents_z));
			return iter_;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(std::enable_if_t<sfinae, const_iterator> iter_,
							  column_traits<0>::rvalue_type value,
							  column_traits<1>::rvalue_type material,
							  column_traits<2>::rvalue_type center_x,
							  column_traits<3>::rvalue_type center_y,
							  column_traits<4>::rvalue_type center_z,
							  column_traits<5>::rvalue_type extents_x,
							  column_traits<6>::rvalue_type extents_y,
							  column_traits<7>::rvalue_type extents_z) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(extents_x),
						   static_cast<column_traits<6>::rvalue_forward_type>(extents_y),
						   static_cast<column_traits<7>::rvalue_forward_type>(extents_z));
			return iter_;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		boxes& insert(size_type index_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_, row_);
			return *this;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(const_iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		template <typename Value,
				  typename Material,
				  typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename ExtentsX,
				  typename ExtentsY,
				  typename ExtentsZ,
				  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, boxes&> emplace(size_type index_,
												 Value&& value,
												 Material&& material,
												 CenterX&& center_x,
												 CenterY&& center_y,
												 CenterZ&& center_z,
												 ExtentsX&& extents_x,
												 ExtentsY&& extents_y,
												 ExtentsZ&& extents_z) //
			noexcept(table_traits::emplace_is_nothrow<table_type&,
													  Value&&,
													  Material&&,
													  CenterX&&,
													  CenterY&&,
													  CenterZ&&,
													  ExtentsX&&,
													  ExtentsY&&,
													  ExtentsZ&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<ExtentsX&&>(extents_x),
						   static_cast<ExtentsY&&>(extents_y),
						   static_cast<ExtentsZ&&>(extents_z));
			return *this;
		}

		template <typename Value,
				  typename Material,
				  typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename ExtentsX,
				  typename ExtentsY,
				  typename ExtentsZ,
				  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> emplace(iterator iter_,
												   Value&& value,
												   Material&& material,
												   CenterX&& center_x,
												   CenterY&& center_y,
												   CenterZ&& center_z,
												   ExtentsX&& extents_x,
												   ExtentsY&& extents_y,
												   ExtentsZ&& extents_z) //
			noexcept(table_traits::emplace_is_nothrow<table_type&,
													  Value&&,
													  Material&&,
													  CenterX&&,
													  CenterY&&,
													  CenterZ&&,
													  ExtentsX&&,
													  ExtentsY&&,
													  ExtentsZ&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<ExtentsX&&>(extents_x),
						   static_cast<ExtentsY&&>(extents_y),
						   static_cast<ExtentsZ&&>(extents_z));
			return iter_;
		}

		template <typename Value,
				  typename Material,
				  typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename ExtentsX,
				  typename ExtentsY,
				  typename ExtentsZ,
				  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> emplace(const_iterator iter_,
														 Value&& value,
														 Material&& material,
														 CenterX&& center_x,
														 CenterY&& center_y,
														 CenterZ&& center_z,
														 ExtentsX&& extents_x,
														 ExtentsY&& extents_y,
														 ExtentsZ&& extents_z) //
			noexcept(table_traits::emplace_is_nothrow<table_type&,
													  Value&&,
													  Material&&,
													  CenterX&&,
													  CenterY&&,
													  CenterZ&&,
													  ExtentsX&&,
													  ExtentsY&&,
													  ExtentsZ&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<ExtentsX&&>(extents_x),
						   static_cast<ExtentsY&&>(extents_y),
						   static_cast<ExtentsZ&&>(extents_z));
			return iter_;
		}

		template <size_type Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(Column < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, Column>>(
				table_.template column<Column>());
		}

		template <size_type Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(Column < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, Column>>(
				table_.template column<Column>());
		}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr rt::box* value() noexcept
		{
			return column<0>();
		}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const rt::box* value() const noexcept
		{
			return column<0>();
		}

		SOAGEN_ALIGNED_COLUMN(1)
		constexpr size_t* material() noexcept
		{
			return column<1>();
		}

		SOAGEN_ALIGNED_COLUMN(1)
		constexpr const size_t* material() const noexcept
		{
			return column<1>();
		}

		SOAGEN_ALIGNED_COLUMN(2)
		constexpr float* center_x() noexcept
		{
			return column<2>();
		}

		SOAGEN_ALIGNED_COLUMN(2)
		constexpr const float* center_x() const noexcept
		{
			return column<2>();
		}

		SOAGEN_ALIGNED_COLUMN(3)
		constexpr float* center_y() noexcept
		{
			return column<3>();
		}

		SOAGEN_ALIGNED_COLUMN(3)
		constexpr const float* center_y() const noexcept
		{
			return column<3>();
		}

		SOAGEN_ALIGNED_COLUMN(4)
		constexpr float* center_z() noexcept
		{
			return column<4>();
		}

		SOAGEN_ALIGNED_COLUMN(4)
		constexpr const float* center_z() const noexcept
		{
			return column<4>();
		}

		SOAGEN_ALIGNED_COLUMN(5)
		constexpr float* extents_x() noexcept
		{
			return column<5>();
		}

		SOAGEN_ALIGNED_COLUMN(5)
		constexpr const float* extents_x() const noexcept
		{
			return column<5>();
		}

		SOAGEN_ALIGNED_COLUMN(6)
		constexpr float* extents_y() noexcept
		{
			return column<6>();
		}

		SOAGEN_ALIGNED_COLUMN(6)
		constexpr const float* extents_y() const noexcept
		{
			return column<6>();
		}

		SOAGEN_ALIGNED_COLUMN(7)
		constexpr float* extents_z() noexcept
		{
			return column<7>();
		}

		SOAGEN_ALIGNED_COLUMN(7)
		constexpr const float* extents_z() const noexcept
		{
			return column<7>();
		}

		template <typename Func>
		constexpr void for_each_column(Func&& func) //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<4>(), size_type{ 4 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<5>(), size_type{ 5 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<6>(), size_type{ 6 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<7>(), size_type{ 7 });
		}

		template <typename Func>
		constexpr void for_each_column(Func&& func) const //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&, true>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<4>(), size_type{ 4 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<5>(), size_type{ 5 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<6>(), size_type{ 6 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<7>(), size_type{ 7 });
		}

		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<boxes&, Columns...> row(size_type index) & noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<Columns>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3, 4, 5, 6, 7>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type operator[](size_type index) & noexcept
		{
			return (*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type at(size_type index) &
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type front() & noexcept
		{
			return (*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type back() & noexcept
		{
			return (*this).row(size() - 1u);
		}

		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<boxes&&, Columns...> row(size_type index) && noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { std::move(this->template column<Columns>()[index]) }... };
			}
			else
			{
				return std::move(*this).template row<0, 1, 2, 3, 4, 5, 6, 7>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type operator[](size_type index) && noexcept
		{
			return std::move(*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type at(size_type index) &&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return std::move(*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type front() && noexcept
		{
			return std::move(*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type back() && noexcept
		{
			return std::move(*this).row(size() - 1u);
		}

		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<const boxes&, Columns...> row(size_type index) const& noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<Columns>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3, 4, 5, 6, 7>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type operator[](size_type index) const& noexcept
		{
			return (*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type at(size_type index) const&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type front() const& noexcept
		{
			return (*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type back() const& noexcept
		{
			return (*this).row(size() - 1u);
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<boxes&, Columns...> begin() & noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<boxes&, Columns...> end() & noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<boxes&&, Columns...> begin() && noexcept
		{
			return { std::move(*this), 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<boxes&&, Columns...> end() && noexcept
		{
			return { std::move(*this), static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const boxes&, Columns...> begin() const& noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const boxes&, Columns...> end() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const boxes&, Columns...> cbegin() const& noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const boxes&, Columns...> cend() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}
	};

	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<boxes>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(boxes& lhs, boxes& rhs) //
		noexcept(soagen::has_nothrow_swap_member<boxes>)
	{
		lhs.swap(rhs);
	}
}

//----------------------------------------------------------------------------------------------------------------------
// materials
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	class SOAGEN_EMPTY_BASES materials //
		: public soagen::mixins::resizable<materials>,
		  public soagen::mixins::equality_comparable<materials>,
		  public soagen::mixins::less_than_comparable<materials>,
		  public soagen::mixins::data_ptr<materials>,
		  public soagen::mixins::const_data_ptr<materials>,
		  public soagen::mixins::swappable<materials>
	{
	  public:
		using size_type = std::size_t;

		using difference_type = std::ptrdiff_t;

		using allocator_type = soagen::allocator_type<materials>;

		using table_type = soagen::table_type<materials>;

		using table_traits = soagen::table_traits_type<materials>;

		static constexpr size_t column_count = soagen::table_traits_type<materials>::column_count;

		template <size_type Column>
		using column_traits = typename table_traits::template column<Column>;

		template <size_type Column>
		using column_type = typename column_traits<Column>::value_type;

		using iterator = soagen::iterator_type<materials&>;

		using const_iterator = soagen::iterator_type<const materials&>;

		using rvalue_iterator = soagen::iterator_type<materials&&>;

		using row_type = soagen::row_type<materials&>;

		using const_row_type = soagen::row_type<const materials&>;

		using rvalue_row_type = soagen::row_type<materials&&>;

		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		struct column_indices
		{
			static constexpr size_type colour = 0;
		};

		template <size_type Column>
		static constexpr auto& column_name = soagen::detail::col_name_<materials, Column>::value;

	  private:
		table_type table_;

	  public:
		SOAGEN_NODISCARD_CTOR
		materials() = default;

		SOAGEN_NODISCARD_CTOR
		materials(materials&&) = default;

		materials& operator=(materials&&) = default;

		SOAGEN_NODISCARD_CTOR
		materials(const materials&) = default;

		materials& operator=(const materials&) = default;

		~materials() = default;

		SOAGEN_NODISCARD_CTOR
		constexpr explicit materials(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		SOAGEN_NODISCARD_CTOR
		constexpr explicit materials(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type allocation_size() const noexcept
		{
			return table_.allocation_size();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		materials& reserve(size_type new_cap) //
			noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
			return *this;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		materials& shrink_to_fit() //
			noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
			return *this;
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		materials& clear() noexcept
		{
			table_.clear();
			return *this;
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, materials&> erase(size_type pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
			return *this;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<size_type>> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			return table_.unordered_erase(pos);
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> erase(iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<iterator>> unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<const_iterator>> unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		materials& pop_back(size_type num = 1) //
			noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
			return *this;
		}

		SOAGEN_CPP20_CONSTEXPR
		materials& push_back(column_traits<0>::param_type colour) //
			noexcept(table_traits::push_back_is_nothrow<table_type&>)
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(colour));
			return *this;
		}

		template <bool sfinae = table_traits::rvalue_type_list_is_distinct>
		SOAGEN_CPP20_CONSTEXPR
		materials& push_back(std::enable_if_t<sfinae, column_traits<0>::rvalue_type> colour) //
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct)					 //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(colour));
			return *this;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<soagen::is_soa<soagen::remove_cvref<Table>>, int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		materials& push_back(const soagen::row<Table, Columns...>& row_)	 //
			noexcept(table_traits::row_push_back_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>) //
		{
			table_.emplace_back(row_);
			return *this;
		}

		template <typename Colour>
		SOAGEN_CPP20_CONSTEXPR
		materials& emplace_back(Colour&& colour) //
			noexcept(table_traits::emplace_back_is_nothrow<table_type&, Colour&&>)
		{
			table_.emplace_back(static_cast<Colour&&>(colour));
			return *this;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, materials&> insert(size_type index_, column_traits<0>::param_type colour) //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable)  //
		{
			table_.emplace(index_, static_cast<column_traits<0>::param_forward_type>(colour));
			return *this;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> insert(iterator iter_, column_traits<0>::param_type colour)	  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<column_traits<0>::param_forward_type>(colour));
			return iter_;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> insert(const_iterator iter_, column_traits<0>::param_type colour) //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable)		   //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<column_traits<0>::param_forward_type>(colour));
			return iter_;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		materials& insert(std::enable_if_t<sfinae, size_type> index_, column_traits<0>::rvalue_type colour) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_, static_cast<column_traits<0>::rvalue_forward_type>(colour));
			return *this;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(std::enable_if_t<sfinae, iterator> iter_, column_traits<0>::rvalue_type colour) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<column_traits<0>::rvalue_forward_type>(colour));
			return iter_;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(std::enable_if_t<sfinae, const_iterator> iter_, column_traits<0>::rvalue_type colour) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<column_traits<0>::rvalue_forward_type>(colour));
			return iter_;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		materials& insert(size_type index_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_, row_);
			return *this;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(const_iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		template <typename Colour,
				  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, materials&> emplace(size_type index_, Colour&& colour)					  //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Colour&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_, static_cast<Colour&&>(colour));
			return *this;
		}

		template <typename Colour,
				  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> emplace(iterator iter_, Colour&& colour)						  //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Colour&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Colour&&>(colour));
			return iter_;
		}

		template <typename Colour,
				  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> emplace(const_iterator iter_, Colour&& colour)			  //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Colour&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Colour&&>(colour));
			return iter_;
		}

		template <size_type Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(Column < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, Column>>(
				table_.template column<Column>());
		}

		template <size_type Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(Column < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, Column>>(
				table_.template column<Column>());
		}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr rt::colour* colour() noexcept
		{
			return column<0>();
		}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const rt::colour* colour() const noexcept
		{
			return column<0>();
		}

		template <typename Func>
		constexpr void for_each_column(Func&& func) //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
		}

		template <typename Func>
		constexpr void for_each_column(Func&& func) const //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&, true>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
		}

		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<materials&, Columns...> row(size_type index) & noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<Columns>()[index] }... };
			}
			else
			{
				return (*this).template row<0>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type operator[](size_type index) & noexcept
		{
			return (*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type at(size_type index) &
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type front() & noexcept
		{
			return (*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type back() & noexcept
		{
			return (*this).row(size() - 1u);
		}

		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<materials&&, Columns...> row(size_type index) && noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { std::move(this->template column<Columns>()[index]) }... };
			}
			else
			{
				return std::move(*this).template row<0>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type operator[](size_type index) && noexcept
		{
			return std::move(*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type at(size_type index) &&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return std::move(*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type front() && noexcept
		{
			return std::move(*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type back() && noexcept
		{
			return std::move(*this).row(size() - 1u);
		}

		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<const materials&, Columns...> row(size_type index) const& noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<Columns>()[index] }... };
			}
			else
			{
				return (*this).template row<0>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type operator[](size_type index) const& noexcept
		{
			return (*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type at(size_type index) const&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type front() const& noexcept
		{
			return (*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type back() const& noexcept
		{
			return (*this).row(size() - 1u);
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<materials&, Columns...> begin() & noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<materials&, Columns...> end() & noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<materials&&, Columns...> begin() && noexcept
		{
			return { std::move(*this), 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<materials&&, Columns...> end() && noexcept
		{
			return { std::move(*this), static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const materials&, Columns...> begin() const& noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const materials&, Columns...> end() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const materials&, Columns...> cbegin() const& noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const materials&, Columns...> cend() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}
	};

	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<materials>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(materials& lhs, materials& rhs) //
		noexcept(soagen::has_nothrow_swap_member<materials>)
	{
		lhs.swap(rhs);
	}
}

//----------------------------------------------------------------------------------------------------------------------
// planes
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	class SOAGEN_EMPTY_BASES planes //
		: public soagen::mixins::resizable<planes>,
		  public soagen::mixins::equality_comparable<planes>,
		  public soagen::mixins::less_than_comparable<planes>,
		  public soagen::mixins::data_ptr<planes>,
		  public soagen::mixins::const_data_ptr<planes>,
		  public soagen::mixins::swappable<planes>
	{
	  public:
		using size_type = std::size_t;

		using difference_type = std::ptrdiff_t;

		using allocator_type = soagen::allocator_type<planes>;

		using table_type = soagen::table_type<planes>;

		using table_traits = soagen::table_traits_type<planes>;

		static constexpr size_t column_count = soagen::table_traits_type<planes>::column_count;

		template <size_type Column>
		using column_traits = typename table_traits::template column<Column>;

		template <size_type Column>
		using column_type = typename column_traits<Column>::value_type;

		using iterator = soagen::iterator_type<planes&>;

		using const_iterator = soagen::iterator_type<const planes&>;

		using rvalue_iterator = soagen::iterator_type<planes&&>;

		using row_type = soagen::row_type<planes&>;

		using const_row_type = soagen::row_type<const planes&>;

		using rvalue_row_type = soagen::row_type<planes&&>;

		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		struct column_indices
		{
			static constexpr size_type value	= 0;
			static constexpr size_type material = 1;
			static constexpr size_type normal_x = 2;
			static constexpr size_type normal_y = 3;
			static constexpr size_type normal_z = 4;
			static constexpr size_type d		= 5;
		};

		template <size_type Column>
		static constexpr auto& column_name = soagen::detail::col_name_<planes, Column>::value;

	  private:
		table_type table_;

	  public:
		SOAGEN_NODISCARD_CTOR
		planes() = default;

		SOAGEN_NODISCARD_CTOR
		planes(planes&&) = default;

		planes& operator=(planes&&) = default;

		SOAGEN_NODISCARD_CTOR
		planes(const planes&) = default;

		planes& operator=(const planes&) = default;

		~planes() = default;

		SOAGEN_NODISCARD_CTOR
		constexpr explicit planes(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		SOAGEN_NODISCARD_CTOR
		constexpr explicit planes(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type allocation_size() const noexcept
		{
			return table_.allocation_size();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		planes& reserve(size_type new_cap) //
			noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
			return *this;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		planes& shrink_to_fit() //
			noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
			return *this;
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		planes& clear() noexcept
		{
			table_.clear();
			return *this;
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, planes&> erase(size_type pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
			return *this;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<size_type>> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			return table_.unordered_erase(pos);
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> erase(iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<iterator>> unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<const_iterator>> unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		planes& pop_back(size_type num = 1) //
			noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
			return *this;
		}

		SOAGEN_CPP20_CONSTEXPR
		planes& push_back(column_traits<0>::param_type value,
						  column_traits<1>::param_type material,
						  column_traits<2>::param_type normal_x,
						  column_traits<3>::param_type normal_y,
						  column_traits<4>::param_type normal_z,
						  column_traits<5>::param_type d) //
			noexcept(table_traits::push_back_is_nothrow<table_type&>)
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(value),
								static_cast<column_traits<1>::param_forward_type>(material),
								static_cast<column_traits<2>::param_forward_type>(normal_x),
								static_cast<column_traits<3>::param_forward_type>(normal_y),
								static_cast<column_traits<4>::param_forward_type>(normal_z),
								static_cast<column_traits<5>::param_forward_type>(d));
			return *this;
		}

		template <bool sfinae = table_traits::rvalue_type_list_is_distinct>
		SOAGEN_CPP20_CONSTEXPR
		planes& push_back(std::enable_if_t<sfinae, column_traits<0>::rvalue_type> value,
						  column_traits<1>::rvalue_type material,
						  column_traits<2>::rvalue_type normal_x,
						  column_traits<3>::rvalue_type normal_y,
						  column_traits<4>::rvalue_type normal_z,
						  column_traits<5>::rvalue_type d)					//
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct) //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(value),
								static_cast<column_traits<1>::rvalue_forward_type>(material),
								static_cast<column_traits<2>::rvalue_forward_type>(normal_x),
								static_cast<column_traits<3>::rvalue_forward_type>(normal_y),
								static_cast<column_traits<4>::rvalue_forward_type>(normal_z),
								static_cast<column_traits<5>::rvalue_forward_type>(d));
			return *this;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<soagen::is_soa<soagen::remove_cvref<Table>>, int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		planes& push_back(const soagen::row<Table, Columns...>& row_)		 //
			noexcept(table_traits::row_push_back_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>) //
		{
			table_.emplace_back(row_);
			return *this;
		}

		template <typename Value, typename Material, typename NormalX, typename NormalY, typename NormalZ, typename D>
		SOAGEN_CPP20_CONSTEXPR
		planes& emplace_back(Value&& value,
							 Material&& material,
							 NormalX&& normal_x,
							 NormalY&& normal_y,
							 NormalZ&& normal_z,
							 D&& d) //
			noexcept(
				table_traits::
					emplace_back_is_nothrow<table_type&, Value&&, Material&&, NormalX&&, NormalY&&, NormalZ&&, D&&>)
		{
			table_.emplace_back(static_cast<Value&&>(value),
								static_cast<Material&&>(material),
								static_cast<NormalX&&>(normal_x),
								static_cast<NormalY&&>(normal_y),
								static_cast<NormalZ&&>(normal_z),
								static_cast<D&&>(d));
			return *this;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, planes&> insert(size_type index_,
												 column_traits<0>::param_type value,
												 column_traits<1>::param_type material,
												 column_traits<2>::param_type normal_x,
												 column_traits<3>::param_type normal_y,
												 column_traits<4>::param_type normal_z,
												 column_traits<5>::param_type d)						  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(normal_x),
						   static_cast<column_traits<3>::param_forward_type>(normal_y),
						   static_cast<column_traits<4>::param_forward_type>(normal_z),
						   static_cast<column_traits<5>::param_forward_type>(d));
			return *this;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> insert(iterator iter_,
												  column_traits<0>::param_type value,
												  column_traits<1>::param_type material,
												  column_traits<2>::param_type normal_x,
												  column_traits<3>::param_type normal_y,
												  column_traits<4>::param_type normal_z,
												  column_traits<5>::param_type d)						  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(normal_x),
						   static_cast<column_traits<3>::param_forward_type>(normal_y),
						   static_cast<column_traits<4>::param_forward_type>(normal_z),
						   static_cast<column_traits<5>::param_forward_type>(d));
			return iter_;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> insert(const_iterator iter_,
														column_traits<0>::param_type value,
														column_traits<1>::param_type material,
														column_traits<2>::param_type normal_x,
														column_traits<3>::param_type normal_y,
														column_traits<4>::param_type normal_z,
														column_traits<5>::param_type d)					  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(normal_x),
						   static_cast<column_traits<3>::param_forward_type>(normal_y),
						   static_cast<column_traits<4>::param_forward_type>(normal_z),
						   static_cast<column_traits<5>::param_forward_type>(d));
			return iter_;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		planes& insert(std::enable_if_t<sfinae, size_type> index_,
					   column_traits<0>::rvalue_type value,
					   column_traits<1>::rvalue_type material,
					   column_traits<2>::rvalue_type normal_x,
					   column_traits<3>::rvalue_type normal_y,
					   column_traits<4>::rvalue_type normal_z,
					   column_traits<5>::rvalue_type d) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(normal_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(normal_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(normal_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(d));
			return *this;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(std::enable_if_t<sfinae, iterator> iter_,
						column_traits<0>::rvalue_type value,
						column_traits<1>::rvalue_type material,
						column_traits<2>::rvalue_type normal_x,
						column_traits<3>::rvalue_type normal_y,
						column_traits<4>::rvalue_type normal_z,
						column_traits<5>::rvalue_type d) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(normal_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(normal_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(normal_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(d));
			return iter_;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(std::enable_if_t<sfinae, const_iterator> iter_,
							  column_traits<0>::rvalue_type value,
							  column_traits<1>::rvalue_type material,
							  column_traits<2>::rvalue_type normal_x,
							  column_traits<3>::rvalue_type normal_y,
							  column_traits<4>::rvalue_type normal_z,
							  column_traits<5>::rvalue_type d) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(normal_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(normal_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(normal_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(d));
			return iter_;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		planes& insert(size_type index_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_, row_);
			return *this;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(const_iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		template <typename Value,
				  typename Material,
				  typename NormalX,
				  typename NormalY,
				  typename NormalZ,
				  typename D,
				  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, planes&> emplace(size_type index_,
												  Value&& value,
												  Material&& material,
												  NormalX&& normal_x,
												  NormalY&& normal_y,
												  NormalZ&& normal_z,
												  D&& d) //
			noexcept(table_traits::
						 emplace_is_nothrow<table_type&, Value&&, Material&&, NormalX&&, NormalY&&, NormalZ&&, D&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<NormalX&&>(normal_x),
						   static_cast<NormalY&&>(normal_y),
						   static_cast<NormalZ&&>(normal_z),
						   static_cast<D&&>(d));
			return *this;
		}

		template <typename Value,
				  typename Material,
				  typename NormalX,
				  typename NormalY,
				  typename NormalZ,
				  typename D,
				  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> emplace(iterator iter_,
												   Value&& value,
												   Material&& material,
												   NormalX&& normal_x,
												   NormalY&& normal_y,
												   NormalZ&& normal_z,
												   D&& d) //
			noexcept(table_traits::
						 emplace_is_nothrow<table_type&, Value&&, Material&&, NormalX&&, NormalY&&, NormalZ&&, D&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<NormalX&&>(normal_x),
						   static_cast<NormalY&&>(normal_y),
						   static_cast<NormalZ&&>(normal_z),
						   static_cast<D&&>(d));
			return iter_;
		}

		template <typename Value,
				  typename Material,
				  typename NormalX,
				  typename NormalY,
				  typename NormalZ,
				  typename D,
				  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> emplace(const_iterator iter_,
														 Value&& value,
														 Material&& material,
														 NormalX&& normal_x,
														 NormalY&& normal_y,
														 NormalZ&& normal_z,
														 D&& d) //
			noexcept(table_traits::
						 emplace_is_nothrow<table_type&, Value&&, Material&&, NormalX&&, NormalY&&, NormalZ&&, D&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<NormalX&&>(normal_x),
						   static_cast<NormalY&&>(normal_y),
						   static_cast<NormalZ&&>(normal_z),
						   static_cast<D&&>(d));
			return iter_;
		}

		template <size_type Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(Column < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, Column>>(
				table_.template column<Column>());
		}

		template <size_type Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(Column < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, Column>>(
				table_.template column<Column>());
		}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr rt::plane* value() noexcept
		{
			return column<0>();
		}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const rt::plane* value() const noexcept
		{
			return column<0>();
		}

		SOAGEN_ALIGNED_COLUMN(1)
		constexpr size_t* material() noexcept
		{
			return column<1>();
		}

		SOAGEN_ALIGNED_COLUMN(1)
		constexpr const size_t* material() const noexcept
		{
			return column<1>();
		}

		SOAGEN_ALIGNED_COLUMN(2)
		constexpr float* normal_x() noexcept
		{
			return column<2>();
		}

		SOAGEN_ALIGNED_COLUMN(2)
		constexpr const float* normal_x() const noexcept
		{
			return column<2>();
		}

		SOAGEN_ALIGNED_COLUMN(3)
		constexpr float* normal_y() noexcept
		{
			return column<3>();
		}

		SOAGEN_ALIGNED_COLUMN(3)
		constexpr const float* normal_y() const noexcept
		{
			return column<3>();
		}

		SOAGEN_ALIGNED_COLUMN(4)
		constexpr float* normal_z() noexcept
		{
			return column<4>();
		}

		SOAGEN_ALIGNED_COLUMN(4)
		constexpr const float* normal_z() const noexcept
		{
			return column<4>();
		}

		SOAGEN_ALIGNED_COLUMN(5)
		constexpr float* d() noexcept
		{
			return column<5>();
		}

		SOAGEN_ALIGNED_COLUMN(5)
		constexpr const float* d() const noexcept
		{
			return column<5>();
		}

		template <typename Func>
		constexpr void for_each_column(Func&& func) //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<4>(), size_type{ 4 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<5>(), size_type{ 5 });
		}

		template <typename Func>
		constexpr void for_each_column(Func&& func) const //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&, true>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<4>(), size_type{ 4 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<5>(), size_type{ 5 });
		}

		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<planes&, Columns...> row(size_type index) & noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<Columns>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3, 4, 5>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type operator[](size_type index) & noexcept
		{
			return (*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type at(size_type index) &
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type front() & noexcept
		{
			return (*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type back() & noexcept
		{
			return (*this).row(size() - 1u);
		}

		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<planes&&, Columns...> row(size_type index) && noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { std::move(this->template column<Columns>()[index]) }... };
			}
			else
			{
				return std::move(*this).template row<0, 1, 2, 3, 4, 5>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type operator[](size_type index) && noexcept
		{
			return std::move(*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type at(size_type index) &&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return std::move(*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type front() && noexcept
		{
			return std::move(*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type back() && noexcept
		{
			return std::move(*this).row(size() - 1u);
		}

		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<const planes&, Columns...> row(size_type index) const& noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<Columns>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3, 4, 5>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type operator[](size_type index) const& noexcept
		{
			return (*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type at(size_type index) const&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type front() const& noexcept
		{
			return (*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type back() const& noexcept
		{
			return (*this).row(size() - 1u);
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<planes&, Columns...> begin() & noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<planes&, Columns...> end() & noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<planes&&, Columns...> begin() && noexcept
		{
			return { std::move(*this), 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<planes&&, Columns...> end() && noexcept
		{
			return { std::move(*this), static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const planes&, Columns...> begin() const& noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const planes&, Columns...> end() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const planes&, Columns...> cbegin() const& noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const planes&, Columns...> cend() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}
	};

	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<planes>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(planes& lhs, planes& rhs) //
		noexcept(soagen::has_nothrow_swap_member<planes>)
	{
		lhs.swap(rhs);
	}
}

//----------------------------------------------------------------------------------------------------------------------
// spheres
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	class SOAGEN_EMPTY_BASES spheres //
		: public soagen::mixins::resizable<spheres>,
		  public soagen::mixins::equality_comparable<spheres>,
		  public soagen::mixins::less_than_comparable<spheres>,
		  public soagen::mixins::data_ptr<spheres>,
		  public soagen::mixins::const_data_ptr<spheres>,
		  public soagen::mixins::swappable<spheres>
	{
	  public:
		using size_type = std::size_t;

		using difference_type = std::ptrdiff_t;

		using allocator_type = soagen::allocator_type<spheres>;

		using table_type = soagen::table_type<spheres>;

		using table_traits = soagen::table_traits_type<spheres>;

		static constexpr size_t column_count = soagen::table_traits_type<spheres>::column_count;

		template <size_type Column>
		using column_traits = typename table_traits::template column<Column>;

		template <size_type Column>
		using column_type = typename column_traits<Column>::value_type;

		using iterator = soagen::iterator_type<spheres&>;

		using const_iterator = soagen::iterator_type<const spheres&>;

		using rvalue_iterator = soagen::iterator_type<spheres&&>;

		using row_type = soagen::row_type<spheres&>;

		using const_row_type = soagen::row_type<const spheres&>;

		using rvalue_row_type = soagen::row_type<spheres&&>;

		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		struct column_indices
		{
			static constexpr size_type value	= 0;
			static constexpr size_type material = 1;
			static constexpr size_type center_x = 2;
			static constexpr size_type center_y = 3;
			static constexpr size_type center_z = 4;
			static constexpr size_type radius	= 5;
		};

		template <size_type Column>
		static constexpr auto& column_name = soagen::detail::col_name_<spheres, Column>::value;

	  private:
		table_type table_;

	  public:
		SOAGEN_NODISCARD_CTOR
		spheres() = default;

		SOAGEN_NODISCARD_CTOR
		spheres(spheres&&) = default;

		spheres& operator=(spheres&&) = default;

		SOAGEN_NODISCARD_CTOR
		spheres(const spheres&) = default;

		spheres& operator=(const spheres&) = default;

		~spheres() = default;

		SOAGEN_NODISCARD_CTOR
		constexpr explicit spheres(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		SOAGEN_NODISCARD_CTOR
		constexpr explicit spheres(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type allocation_size() const noexcept
		{
			return table_.allocation_size();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& reserve(size_type new_cap) //
			noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
			return *this;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& shrink_to_fit() //
			noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
			return *this;
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& clear() noexcept
		{
			table_.clear();
			return *this;
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, spheres&> erase(size_type pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
			return *this;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<size_type>> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			return table_.unordered_erase(pos);
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> erase(iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<iterator>> unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<const_iterator>> unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& pop_back(size_type num = 1) //
			noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
			return *this;
		}

		SOAGEN_CPP20_CONSTEXPR
		spheres& push_back(column_traits<0>::param_type value,
						   column_traits<1>::param_type material,
						   column_traits<2>::param_type center_x,
						   column_traits<3>::param_type center_y,
						   column_traits<4>::param_type center_z,
						   column_traits<5>::param_type radius) //
			noexcept(table_traits::push_back_is_nothrow<table_type&>)
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(value),
								static_cast<column_traits<1>::param_forward_type>(material),
								static_cast<column_traits<2>::param_forward_type>(center_x),
								static_cast<column_traits<3>::param_forward_type>(center_y),
								static_cast<column_traits<4>::param_forward_type>(center_z),
								static_cast<column_traits<5>::param_forward_type>(radius));
			return *this;
		}

		template <bool sfinae = table_traits::rvalue_type_list_is_distinct>
		SOAGEN_CPP20_CONSTEXPR
		spheres& push_back(std::enable_if_t<sfinae, column_traits<0>::rvalue_type> value,
						   column_traits<1>::rvalue_type material,
						   column_traits<2>::rvalue_type center_x,
						   column_traits<3>::rvalue_type center_y,
						   column_traits<4>::rvalue_type center_z,
						   column_traits<5>::rvalue_type radius)			//
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct) //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(value),
								static_cast<column_traits<1>::rvalue_forward_type>(material),
								static_cast<column_traits<2>::rvalue_forward_type>(center_x),
								static_cast<column_traits<3>::rvalue_forward_type>(center_y),
								static_cast<column_traits<4>::rvalue_forward_type>(center_z),
								static_cast<column_traits<5>::rvalue_forward_type>(radius));
			return *this;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<soagen::is_soa<soagen::remove_cvref<Table>>, int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		spheres& push_back(const soagen::row<Table, Columns...>& row_)		 //
			noexcept(table_traits::row_push_back_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>) //
		{
			table_.emplace_back(row_);
			return *this;
		}

		template <typename Value,
				  typename Material,
				  typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename Radius>
		SOAGEN_CPP20_CONSTEXPR
		spheres& emplace_back(Value&& value,
							  Material&& material,
							  CenterX&& center_x,
							  CenterY&& center_y,
							  CenterZ&& center_z,
							  Radius&& radius) //
			noexcept(table_traits::emplace_back_is_nothrow<table_type&,
														   Value&&,
														   Material&&,
														   CenterX&&,
														   CenterY&&,
														   CenterZ&&,
														   Radius&&>)
		{
			table_.emplace_back(static_cast<Value&&>(value),
								static_cast<Material&&>(material),
								static_cast<CenterX&&>(center_x),
								static_cast<CenterY&&>(center_y),
								static_cast<CenterZ&&>(center_z),
								static_cast<Radius&&>(radius));
			return *this;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, spheres&> insert(size_type index_,
												  column_traits<0>::param_type value,
												  column_traits<1>::param_type material,
												  column_traits<2>::param_type center_x,
												  column_traits<3>::param_type center_y,
												  column_traits<4>::param_type center_z,
												  column_traits<5>::param_type radius)					  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(center_x),
						   static_cast<column_traits<3>::param_forward_type>(center_y),
						   static_cast<column_traits<4>::param_forward_type>(center_z),
						   static_cast<column_traits<5>::param_forward_type>(radius));
			return *this;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> insert(iterator iter_,
												  column_traits<0>::param_type value,
												  column_traits<1>::param_type material,
												  column_traits<2>::param_type center_x,
												  column_traits<3>::param_type center_y,
												  column_traits<4>::param_type center_z,
												  column_traits<5>::param_type radius)					  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(center_x),
						   static_cast<column_traits<3>::param_forward_type>(center_y),
						   static_cast<column_traits<4>::param_forward_type>(center_z),
						   static_cast<column_traits<5>::param_forward_type>(radius));
			return iter_;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> insert(const_iterator iter_,
														column_traits<0>::param_type value,
														column_traits<1>::param_type material,
														column_traits<2>::param_type center_x,
														column_traits<3>::param_type center_y,
														column_traits<4>::param_type center_z,
														column_traits<5>::param_type radius)			  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(value),
						   static_cast<column_traits<1>::param_forward_type>(material),
						   static_cast<column_traits<2>::param_forward_type>(center_x),
						   static_cast<column_traits<3>::param_forward_type>(center_y),
						   static_cast<column_traits<4>::param_forward_type>(center_z),
						   static_cast<column_traits<5>::param_forward_type>(radius));
			return iter_;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		spheres& insert(std::enable_if_t<sfinae, size_type> index_,
						column_traits<0>::rvalue_type value,
						column_traits<1>::rvalue_type material,
						column_traits<2>::rvalue_type center_x,
						column_traits<3>::rvalue_type center_y,
						column_traits<4>::rvalue_type center_z,
						column_traits<5>::rvalue_type radius) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(radius));
			return *this;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(std::enable_if_t<sfinae, iterator> iter_,
						column_traits<0>::rvalue_type value,
						column_traits<1>::rvalue_type material,
						column_traits<2>::rvalue_type center_x,
						column_traits<3>::rvalue_type center_y,
						column_traits<4>::rvalue_type center_z,
						column_traits<5>::rvalue_type radius) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(radius));
			return iter_;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(std::enable_if_t<sfinae, const_iterator> iter_,
							  column_traits<0>::rvalue_type value,
							  column_traits<1>::rvalue_type material,
							  column_traits<2>::rvalue_type center_x,
							  column_traits<3>::rvalue_type center_y,
							  column_traits<4>::rvalue_type center_z,
							  column_traits<5>::rvalue_type radius) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(value),
						   static_cast<column_traits<1>::rvalue_forward_type>(material),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<3>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<4>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<5>::rvalue_forward_type>(radius));
			return iter_;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		spheres& insert(size_type index_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_, row_);
			return *this;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		template <typename Table,
				  size_t... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(const_iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		template <typename Value,
				  typename Material,
				  typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename Radius,
				  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, spheres&> emplace(size_type index_,
												   Value&& value,
												   Material&& material,
												   CenterX&& center_x,
												   CenterY&& center_y,
												   CenterZ&& center_z,
												   Radius&& radius) //
			noexcept(
				table_traits::
					emplace_is_nothrow<table_type&, Value&&, Material&&, CenterX&&, CenterY&&, CenterZ&&, Radius&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<Radius&&>(radius));
			return *this;
		}

		template <typename Value,
				  typename Material,
				  typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename Radius,
				  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> emplace(iterator iter_,
												   Value&& value,
												   Material&& material,
												   CenterX&& center_x,
												   CenterY&& center_y,
												   CenterZ&& center_z,
												   Radius&& radius) //
			noexcept(
				table_traits::
					emplace_is_nothrow<table_type&, Value&&, Material&&, CenterX&&, CenterY&&, CenterZ&&, Radius&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<Radius&&>(radius));
			return iter_;
		}

		template <typename Value,
				  typename Material,
				  typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename Radius,
				  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> emplace(const_iterator iter_,
														 Value&& value,
														 Material&& material,
														 CenterX&& center_x,
														 CenterY&& center_y,
														 CenterZ&& center_z,
														 Radius&& radius) //
			noexcept(
				table_traits::
					emplace_is_nothrow<table_type&, Value&&, Material&&, CenterX&&, CenterY&&, CenterZ&&, Radius&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Value&&>(value),
						   static_cast<Material&&>(material),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<Radius&&>(radius));
			return iter_;
		}

		template <size_type Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(Column < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, Column>>(
				table_.template column<Column>());
		}

		template <size_type Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(Column < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, Column>>(
				table_.template column<Column>());
		}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr rt::sphere* value() noexcept
		{
			return column<0>();
		}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const rt::sphere* value() const noexcept
		{
			return column<0>();
		}

		SOAGEN_ALIGNED_COLUMN(1)
		constexpr size_t* material() noexcept
		{
			return column<1>();
		}

		SOAGEN_ALIGNED_COLUMN(1)
		constexpr const size_t* material() const noexcept
		{
			return column<1>();
		}

		SOAGEN_ALIGNED_COLUMN(2)
		constexpr float* center_x() noexcept
		{
			return column<2>();
		}

		SOAGEN_ALIGNED_COLUMN(2)
		constexpr const float* center_x() const noexcept
		{
			return column<2>();
		}

		SOAGEN_ALIGNED_COLUMN(3)
		constexpr float* center_y() noexcept
		{
			return column<3>();
		}

		SOAGEN_ALIGNED_COLUMN(3)
		constexpr const float* center_y() const noexcept
		{
			return column<3>();
		}

		SOAGEN_ALIGNED_COLUMN(4)
		constexpr float* center_z() noexcept
		{
			return column<4>();
		}

		SOAGEN_ALIGNED_COLUMN(4)
		constexpr const float* center_z() const noexcept
		{
			return column<4>();
		}

		SOAGEN_ALIGNED_COLUMN(5)
		constexpr float* radius() noexcept
		{
			return column<5>();
		}

		SOAGEN_ALIGNED_COLUMN(5)
		constexpr const float* radius() const noexcept
		{
			return column<5>();
		}

		template <typename Func>
		constexpr void for_each_column(Func&& func) //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<4>(), size_type{ 4 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<5>(), size_type{ 5 });
		}

		template <typename Func>
		constexpr void for_each_column(Func&& func) const //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&, true>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<4>(), size_type{ 4 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<5>(), size_type{ 5 });
		}

		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<spheres&, Columns...> row(size_type index) & noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<Columns>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3, 4, 5>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type operator[](size_type index) & noexcept
		{
			return (*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type at(size_type index) &
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type front() & noexcept
		{
			return (*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type back() & noexcept
		{
			return (*this).row(size() - 1u);
		}

		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<spheres&&, Columns...> row(size_type index) && noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { std::move(this->template column<Columns>()[index]) }... };
			}
			else
			{
				return std::move(*this).template row<0, 1, 2, 3, 4, 5>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type operator[](size_type index) && noexcept
		{
			return std::move(*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type at(size_type index) &&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return std::move(*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type front() && noexcept
		{
			return std::move(*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type back() && noexcept
		{
			return std::move(*this).row(size() - 1u);
		}

		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<const spheres&, Columns...> row(size_type index) const& noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<Columns>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3, 4, 5>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type operator[](size_type index) const& noexcept
		{
			return (*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type at(size_type index) const&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type front() const& noexcept
		{
			return (*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type back() const& noexcept
		{
			return (*this).row(size() - 1u);
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<spheres&, Columns...> begin() & noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<spheres&, Columns...> end() & noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<spheres&&, Columns...> begin() && noexcept
		{
			return { std::move(*this), 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<spheres&&, Columns...> end() && noexcept
		{
			return { std::move(*this), static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const spheres&, Columns...> begin() const& noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const spheres&, Columns...> end() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const spheres&, Columns...> cbegin() const& noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const spheres&, Columns...> cend() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}
	};

	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<spheres>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(spheres& lhs, spheres& rhs) //
		noexcept(soagen::has_nothrow_swap_member<spheres>)
	{
		lhs.swap(rhs);
	}
}

#if SOAGEN_MSVC_LIKE
	#pragma pop_macro("min")
	#pragma pop_macro("max")
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(off)
#endif
SOAGEN_POP_WARNINGS;
