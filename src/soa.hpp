//----------------------------------------------------------------------------------------------------------------------
// This file was generated by soagen - do not modify it directly
// https://github.com/marzer/soagen
//----------------------------------------------------------------------------------------------------------------------
#pragma once

/// @file
/// @brief Contains the definitions of rt::boxes, rt::materials, rt::planes, rt::spheres.
///
/// @note This file was generated by soagen - https://github.com/marzer/soagen

#include "colour.hpp"
#include "common.hpp"

#include <soagen.hpp>

SOAGEN_PUSH_WARNINGS;
SOAGEN_DISABLE_SPAM_WARNINGS;
#if SOAGEN_MSVC
	#pragma inline_recursion(on)
#endif
#if SOAGEN_MSVC_LIKE
	#pragma push_macro("min")
	#pragma push_macro("max")
	#undef min
	#undef max
#endif

//----------------------------------------------------------------------------------------------------------------------
// forward declarations
//----------------------------------------------------------------------------------------------------------------------

/// @cond

namespace rt
{
	class boxes;
	class materials;
	class planes;
	class spheres;
}

/// @endcond

//----------------------------------------------------------------------------------------------------------------------
// boxes
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	/// @addtogroup soa Struct-of-Arrays
	/// @{

	/// @addtogroup soa_boxes boxes
	/// @{

	/// @brief boxes
	///
	/// @note The code for this class was generated by soagen - https://github.com/marzer/soagen
	class boxes
	{
	  private:
		/// @cond

		template <typename ValueType,
				  typename ParamType = soagen::param_type<ValueType>,
				  size_t Align		 = alignof(ValueType)>
		using make_col = soagen::column_traits<ValueType, ParamType, soagen::max(Align, alignof(ValueType))>;

		/// @endcond

	  public:
		using size_type		  = std::size_t;
		using difference_type = std::ptrdiff_t;

		/// @brief The allocator type used by this class.
		using allocator_type = soagen::allocator;

		/// @brief The traits for the entire table.
		using table_traits = soagen::table_traits<
			/*	   value */ make_col<rt::box>,
			/*	material */ make_col<size_t>,
			/*	center_x */ make_col<float, soagen::param_type<float>, 32>,
			/*	center_y */ make_col<float, soagen::param_type<float>, 32>,
			/*	center_z */ make_col<float, soagen::param_type<float>, 32>,
			/* extents_x */ make_col<float, soagen::param_type<float>, 32>,
			/* extents_y */ make_col<float, soagen::param_type<float>, 32>,
			/* extents_z */ make_col<float, soagen::param_type<float>, 32>>;

		/// @brief Gets the traits for a specific column of the table.
		template <size_type I>
		using column_traits = typename table_traits::template column<I>;

		/// @brief Gets the type of a specific column in the table.
		template <size_type I>
		using column_type = typename column_traits<I>::value_type;

		/// @brief The amount of rows to advance to maintain the requested alignment
		///
		/// @details The multiple of rows you need to advance through the table such that
		/// all elements across all columns have the same memory alignment as the beginning of their column
		/// (i.e. they are 'perfectly aligned' with the chosen value for `alignment` in the soagen config).
		///
		/// @note Typically you can ignore this; column elements are always aligned correctly according to their type.
		/// This is for over-alignment scenarios where you need to do things in batches (e.g. SIMD).
		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		struct column_indices
		{
			static constexpr size_type value	 = 0;
			static constexpr size_type material	 = 1;
			static constexpr size_type center_x	 = 2;
			static constexpr size_type center_y	 = 3;
			static constexpr size_type center_z	 = 4;
			static constexpr size_type extents_x = 5;
			static constexpr size_type extents_y = 6;
			static constexpr size_type extents_z = 7;
		};

	  private:
		/// @cond
		// clang-format off
			template <size_type> struct column_name_{};
			template <> struct column_name_<0>{  static constexpr auto value = "value"; };
			template <> struct column_name_<1>{  static constexpr auto value = "material"; };
			template <> struct column_name_<2>{  static constexpr auto value = "center_x"; };
			template <> struct column_name_<3>{  static constexpr auto value = "center_y"; };
			template <> struct column_name_<4>{  static constexpr auto value = "center_z"; };
			template <> struct column_name_<5>{  static constexpr auto value = "extents_x"; };
			template <> struct column_name_<6>{  static constexpr auto value = "extents_y"; };
			template <> struct column_name_<7>{  static constexpr auto value = "extents_z"; };
		// clang-format on

		/// @endcond

	  public:
		/// @brief Gets the name of the specified column as a string.
		template <size_type I>
		static constexpr auto& column_name = column_name_<I>::value;

	  private:
		/// @cond

		using table_type = soagen::table<table_traits, allocator_type>;
		table_type table_;

		/// @endcond

	  public:
		/// @brief Default constructor.
		SOAGEN_NODISCARD_CTOR
		boxes() = default;

		/// @brief Move constructor.
		SOAGEN_NODISCARD_CTOR
		boxes(boxes&&) = default;

		/// @brief Move-assignment operator.
		boxes& operator=(boxes&&) = default;

		/// @brief Copy constructor.
		SOAGEN_NODISCARD_CTOR
		boxes(const boxes&) = default;

		/// @brief Copy-assignment operator.
		boxes& operator=(const boxes&) = default;

		/// @brief Destructor.
		~boxes() = default;

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit boxes(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit boxes(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		/// @name Capacity
		/// @{

		/// @brief Returns true if the number of rows is zero.
		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		/// @brief Returns the current number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		/// @brief Returns the maximum possible number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		/// @brief Reserves storage for (at least) the given number of rows.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& reserve(size_type new_cap) noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
			return *this;
		}

		/// @brief Returns the number of rows that can be held in currently allocated storage.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		/// @brief Frees unused capacity.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& shrink_to_fit() noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
			return *this;
		}

		/// @}

		/// @name Modifiers
		/// @{

		/// @brief Removes all rows from table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& clear() noexcept
		{
			table_.clear();
			return *this;
		}

		/// @brief Erases the row at the given index.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void erase(size_type pos) noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
		}

		/// @brief	Erases the row at the given index without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The index of the row that was moved into the erased row's position, if any.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		soagen::optional<size_type> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			return table_.unordered_erase(pos);
		}

		/// @brief Pushes a new row onto the end of the table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& push_back(column_traits<0>::param_type value,
						 column_traits<1>::param_type material,
						 column_traits<2>::param_type center_x,
						 column_traits<3>::param_type center_y,
						 column_traits<4>::param_type center_z,
						 column_traits<5>::param_type extents_x,
						 column_traits<6>::param_type extents_y,
						 column_traits<7>::param_type extents_z) //
			noexcept(noexcept(std::declval<table_type&>().emplace_back(std::declval<column_traits<0>::param_type&&>(),
																	   std::declval<column_traits<1>::param_type&&>(),
																	   std::declval<column_traits<2>::param_type&&>(),
																	   std::declval<column_traits<3>::param_type&&>(),
																	   std::declval<column_traits<4>::param_type&&>(),
																	   std::declval<column_traits<5>::param_type&&>(),
																	   std::declval<column_traits<6>::param_type&&>(),
																	   std::declval<column_traits<7>::param_type&&>())))
		{
			table_.emplace_back(static_cast<column_traits<0>::param_type&&>(value),
								static_cast<column_traits<1>::param_type&&>(material),
								static_cast<column_traits<2>::param_type&&>(center_x),
								static_cast<column_traits<3>::param_type&&>(center_y),
								static_cast<column_traits<4>::param_type&&>(center_z),
								static_cast<column_traits<5>::param_type&&>(extents_x),
								static_cast<column_traits<6>::param_type&&>(extents_y),
								static_cast<column_traits<7>::param_type&&>(extents_z));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at the end of the table.
		template <typename... Value,
				  typename... Material,
				  typename... CenterX,
				  typename... CenterY,
				  typename... CenterZ,
				  typename... ExtentsX,
				  typename... ExtentsY,
				  typename... ExtentsZ>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& emplace_back(soagen::emplacer<Value...>&& value,
							soagen::emplacer<Material...>&& material,
							soagen::emplacer<CenterX...>&& center_x,
							soagen::emplacer<CenterY...>&& center_y,
							soagen::emplacer<CenterZ...>&& center_z,
							soagen::emplacer<ExtentsX...>&& extents_x,
							soagen::emplacer<ExtentsY...>&& extents_y,
							soagen::emplacer<ExtentsZ...>&& extents_z) //
		{
			table_.emplace_back(static_cast<soagen::emplacer<Value...>&&>(value),
								static_cast<soagen::emplacer<Material...>&&>(material),
								static_cast<soagen::emplacer<CenterX...>&&>(center_x),
								static_cast<soagen::emplacer<CenterY...>&&>(center_y),
								static_cast<soagen::emplacer<CenterZ...>&&>(center_z),
								static_cast<soagen::emplacer<ExtentsX...>&&>(extents_x),
								static_cast<soagen::emplacer<ExtentsY...>&&>(extents_y),
								static_cast<soagen::emplacer<ExtentsZ...>&&>(extents_z));
			return *this;
		}

		/// @brief Removes the last row(s) from the table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& pop_back(size_type num = 1) noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
			return *this;
		}

		/// @brief Resizes the table to the given number of rows.
		///
		/// @availability This method is only available when all the column types are default-constructible.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_resize_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& resize(size_type new_size) noexcept(soagen::has_nothrow_resize_member<table_type, size_type>)
		{
			table_.resize(new_size);
			return *this;
		}

		/// @brief Swaps the contents of the table with another.
		///
		/// @availability This method is only available when #allocator_type is swappable (or non-propagating).
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		constexpr void swap(boxes& other) noexcept(soagen::has_nothrow_swap_member<table_type>)
		{
			table_.swap(other.table_);
		}

		/// @}

		/// @name Element access
		/// @{

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::all_trivially_copyable)
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr std::byte* data() noexcept
		{
			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, 0>>(
				table_.data());
		}

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::all_trivially_copyable)
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const std::byte* data() const noexcept
		{
			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, 0>>(
				table_.data());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <size_t I>
		SOAGEN_ALIGNED_COLUMN(I)
		column_type<I>* column() noexcept
		{
			static_assert(I < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, I>>(
				table_.template column<I>());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <size_t I>
		SOAGEN_ALIGNED_COLUMN(I)
		std::add_const_t<column_type<I>>* column() const noexcept
		{
			static_assert(I < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, I>>(
				table_.template column<I>());
		}

		/// @brief Returns a pointer to the elements in column [0]: value.
		SOAGEN_ALIGNED_COLUMN(0)
		rt::box* value() noexcept
		{
			return column<0>();
		}

		/// @brief Returns a pointer to the elements in column [0]: value.
		SOAGEN_ALIGNED_COLUMN(0)
		const rt::box* value() const noexcept
		{
			return column<0>();
		}

		/// @brief Returns a pointer to the elements in column [1]: material.
		SOAGEN_ALIGNED_COLUMN(1)
		size_t* material() noexcept
		{
			return column<1>();
		}

		/// @brief Returns a pointer to the elements in column [1]: material.
		SOAGEN_ALIGNED_COLUMN(1)
		const size_t* material() const noexcept
		{
			return column<1>();
		}

		/// @brief Returns a pointer to the elements in column [2]: center_x.
		SOAGEN_ALIGNED_COLUMN(2)
		float* center_x() noexcept
		{
			return column<2>();
		}

		/// @brief Returns a pointer to the elements in column [2]: center_x.
		SOAGEN_ALIGNED_COLUMN(2)
		const float* center_x() const noexcept
		{
			return column<2>();
		}

		/// @brief Returns a pointer to the elements in column [3]: center_y.
		SOAGEN_ALIGNED_COLUMN(3)
		float* center_y() noexcept
		{
			return column<3>();
		}

		/// @brief Returns a pointer to the elements in column [3]: center_y.
		SOAGEN_ALIGNED_COLUMN(3)
		const float* center_y() const noexcept
		{
			return column<3>();
		}

		/// @brief Returns a pointer to the elements in column [4]: center_z.
		SOAGEN_ALIGNED_COLUMN(4)
		float* center_z() noexcept
		{
			return column<4>();
		}

		/// @brief Returns a pointer to the elements in column [4]: center_z.
		SOAGEN_ALIGNED_COLUMN(4)
		const float* center_z() const noexcept
		{
			return column<4>();
		}

		/// @brief Returns a pointer to the elements in column [5]: extents_x.
		SOAGEN_ALIGNED_COLUMN(5)
		float* extents_x() noexcept
		{
			return column<5>();
		}

		/// @brief Returns a pointer to the elements in column [5]: extents_x.
		SOAGEN_ALIGNED_COLUMN(5)
		const float* extents_x() const noexcept
		{
			return column<5>();
		}

		/// @brief Returns a pointer to the elements in column [6]: extents_y.
		SOAGEN_ALIGNED_COLUMN(6)
		float* extents_y() noexcept
		{
			return column<6>();
		}

		/// @brief Returns a pointer to the elements in column [6]: extents_y.
		SOAGEN_ALIGNED_COLUMN(6)
		const float* extents_y() const noexcept
		{
			return column<6>();
		}

		/// @brief Returns a pointer to the elements in column [7]: extents_z.
		SOAGEN_ALIGNED_COLUMN(7)
		float* extents_z() noexcept
		{
			return column<7>();
		}

		/// @brief Returns a pointer to the elements in column [7]: extents_z.
		SOAGEN_ALIGNED_COLUMN(7)
		const float* extents_z() const noexcept
		{
			return column<7>();
		}

		/// @}

		/// @brief Returns the allocator being used by the table.
		SOAGEN_INLINE_GETTER
		constexpr allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}
	};

	/// @brief Swaps the contents of two instances of #rt::boxes.
	///
	/// @availability	This overload is only available when #rt::boxes::allocator_type
	/// is swappable (or non-propagating).
	SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<boxes>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(boxes& lhs, boxes& rhs) //
		noexcept(soagen::has_nothrow_swap_member<boxes>)
	{
		lhs.swap(rhs);
	}

	/// @cond

	/// @endcond

	/// @}

	/// @}
}

//----------------------------------------------------------------------------------------------------------------------
// materials
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	/// @addtogroup soa Struct-of-Arrays
	/// @{

	/// @addtogroup soa_materials materials
	/// @{

	/// @brief materials
	///
	/// @note The code for this class was generated by soagen - https://github.com/marzer/soagen
	class materials
	{
	  private:
		/// @cond

		template <typename ValueType,
				  typename ParamType = soagen::param_type<ValueType>,
				  size_t Align		 = alignof(ValueType)>
		using make_col = soagen::column_traits<ValueType, ParamType, soagen::max(Align, alignof(ValueType))>;

		/// @endcond

	  public:
		using size_type		  = std::size_t;
		using difference_type = std::ptrdiff_t;

		/// @brief The allocator type used by this class.
		using allocator_type = soagen::allocator;

		/// @brief The traits for the entire table.
		using table_traits = soagen::table_traits<
			/* colour */ make_col<rt::colour>>;

		/// @brief Gets the traits for a specific column of the table.
		template <size_type I>
		using column_traits = typename table_traits::template column<I>;

		/// @brief Gets the type of a specific column in the table.
		template <size_type I>
		using column_type = typename column_traits<I>::value_type;

		/// @brief The amount of rows to advance to maintain the requested alignment
		///
		/// @details The multiple of rows you need to advance through the table such that
		/// all elements across all columns have the same memory alignment as the beginning of their column
		/// (i.e. they are 'perfectly aligned' with the chosen value for `alignment` in the soagen config).
		///
		/// @note Typically you can ignore this; column elements are always aligned correctly according to their type.
		/// This is for over-alignment scenarios where you need to do things in batches (e.g. SIMD).
		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		struct column_indices
		{
			static constexpr size_type colour = 0;
		};

	  private:
		/// @cond
		// clang-format off
			template <size_type> struct column_name_{};
			template <> struct column_name_<0>{  static constexpr auto value = "colour"; };
		// clang-format on

		/// @endcond

	  public:
		/// @brief Gets the name of the specified column as a string.
		template <size_type I>
		static constexpr auto& column_name = column_name_<I>::value;

	  private:
		/// @cond

		using table_type = soagen::table<table_traits, allocator_type>;
		table_type table_;

		/// @endcond

	  public:
		/// @brief Default constructor.
		SOAGEN_NODISCARD_CTOR
		materials() = default;

		/// @brief Move constructor.
		SOAGEN_NODISCARD_CTOR
		materials(materials&&) = default;

		/// @brief Move-assignment operator.
		materials& operator=(materials&&) = default;

		/// @brief Copy constructor.
		SOAGEN_NODISCARD_CTOR
		materials(const materials&) = default;

		/// @brief Copy-assignment operator.
		materials& operator=(const materials&) = default;

		/// @brief Destructor.
		~materials() = default;

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit materials(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit materials(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		/// @name Capacity
		/// @{

		/// @brief Returns true if the number of rows is zero.
		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		/// @brief Returns the current number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		/// @brief Returns the maximum possible number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		/// @brief Reserves storage for (at least) the given number of rows.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		materials& reserve(size_type new_cap) noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
			return *this;
		}

		/// @brief Returns the number of rows that can be held in currently allocated storage.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		/// @brief Frees unused capacity.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		materials& shrink_to_fit() noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
			return *this;
		}

		/// @}

		/// @name Modifiers
		/// @{

		/// @brief Removes all rows from table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		materials& clear() noexcept
		{
			table_.clear();
			return *this;
		}

		/// @brief Erases the row at the given index.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void erase(size_type pos) noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
		}

		/// @brief	Erases the row at the given index without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The index of the row that was moved into the erased row's position, if any.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		soagen::optional<size_type> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			return table_.unordered_erase(pos);
		}

		/// @brief Pushes a new row onto the end of the table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		materials& push_back(column_traits<0>::param_type colour) //
			noexcept(noexcept(std::declval<table_type&>().emplace_back(std::declval<column_traits<0>::param_type&&>())))
		{
			table_.emplace_back(static_cast<column_traits<0>::param_type&&>(colour));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at the end of the table.
		template <typename... Colour>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		materials& emplace_back(soagen::emplacer<Colour...>&& colour) //
		{
			table_.emplace_back(static_cast<soagen::emplacer<Colour...>&&>(colour));
			return *this;
		}

		/// @brief Removes the last row(s) from the table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		materials& pop_back(size_type num = 1) noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
			return *this;
		}

		/// @brief Resizes the table to the given number of rows.
		///
		/// @availability This method is only available when all the column types are default-constructible.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_resize_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		materials& resize(size_type new_size) noexcept(soagen::has_nothrow_resize_member<table_type, size_type>)
		{
			table_.resize(new_size);
			return *this;
		}

		/// @brief Swaps the contents of the table with another.
		///
		/// @availability This method is only available when #allocator_type is swappable (or non-propagating).
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		constexpr void swap(materials& other) noexcept(soagen::has_nothrow_swap_member<table_type>)
		{
			table_.swap(other.table_);
		}

		/// @}

		/// @name Element access
		/// @{

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::all_trivially_copyable)
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr std::byte* data() noexcept
		{
			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, 0>>(
				table_.data());
		}

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::all_trivially_copyable)
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const std::byte* data() const noexcept
		{
			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, 0>>(
				table_.data());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <size_t I>
		SOAGEN_ALIGNED_COLUMN(I)
		column_type<I>* column() noexcept
		{
			static_assert(I < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, I>>(
				table_.template column<I>());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <size_t I>
		SOAGEN_ALIGNED_COLUMN(I)
		std::add_const_t<column_type<I>>* column() const noexcept
		{
			static_assert(I < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, I>>(
				table_.template column<I>());
		}

		/// @brief Returns a pointer to the elements in column [0]: colour.
		SOAGEN_ALIGNED_COLUMN(0)
		rt::colour* colour() noexcept
		{
			return column<0>();
		}

		/// @brief Returns a pointer to the elements in column [0]: colour.
		SOAGEN_ALIGNED_COLUMN(0)
		const rt::colour* colour() const noexcept
		{
			return column<0>();
		}

		/// @}

		/// @brief Returns the allocator being used by the table.
		SOAGEN_INLINE_GETTER
		constexpr allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}
	};

	/// @brief Swaps the contents of two instances of #rt::materials.
	///
	/// @availability	This overload is only available when #rt::materials::allocator_type
	/// is swappable (or non-propagating).
	SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<materials>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(materials& lhs, materials& rhs) //
		noexcept(soagen::has_nothrow_swap_member<materials>)
	{
		lhs.swap(rhs);
	}

	/// @cond

	/// @endcond

	/// @}

	/// @}
}

//----------------------------------------------------------------------------------------------------------------------
// planes
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	/// @addtogroup soa Struct-of-Arrays
	/// @{

	/// @addtogroup soa_planes planes
	/// @{

	/// @brief planes
	///
	/// @note The code for this class was generated by soagen - https://github.com/marzer/soagen
	class planes
	{
	  private:
		/// @cond

		template <typename ValueType,
				  typename ParamType = soagen::param_type<ValueType>,
				  size_t Align		 = alignof(ValueType)>
		using make_col = soagen::column_traits<ValueType, ParamType, soagen::max(Align, alignof(ValueType))>;

		/// @endcond

	  public:
		using size_type		  = std::size_t;
		using difference_type = std::ptrdiff_t;

		/// @brief The allocator type used by this class.
		using allocator_type = soagen::allocator;

		/// @brief The traits for the entire table.
		using table_traits = soagen::table_traits<
			/*	  value */ make_col<rt::plane>,
			/* material */ make_col<size_t>,
			/* normal_x */ make_col<float, soagen::param_type<float>, 32>,
			/* normal_y */ make_col<float, soagen::param_type<float>, 32>,
			/* normal_z */ make_col<float, soagen::param_type<float>, 32>,
			/*		  d */ make_col<float, soagen::param_type<float>, 32>>;

		/// @brief Gets the traits for a specific column of the table.
		template <size_type I>
		using column_traits = typename table_traits::template column<I>;

		/// @brief Gets the type of a specific column in the table.
		template <size_type I>
		using column_type = typename column_traits<I>::value_type;

		/// @brief The amount of rows to advance to maintain the requested alignment
		///
		/// @details The multiple of rows you need to advance through the table such that
		/// all elements across all columns have the same memory alignment as the beginning of their column
		/// (i.e. they are 'perfectly aligned' with the chosen value for `alignment` in the soagen config).
		///
		/// @note Typically you can ignore this; column elements are always aligned correctly according to their type.
		/// This is for over-alignment scenarios where you need to do things in batches (e.g. SIMD).
		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		struct column_indices
		{
			static constexpr size_type value	= 0;
			static constexpr size_type material = 1;
			static constexpr size_type normal_x = 2;
			static constexpr size_type normal_y = 3;
			static constexpr size_type normal_z = 4;
			static constexpr size_type d		= 5;
		};

	  private:
		/// @cond
		// clang-format off
			template <size_type> struct column_name_{};
			template <> struct column_name_<0>{  static constexpr auto value = "value"; };
			template <> struct column_name_<1>{  static constexpr auto value = "material"; };
			template <> struct column_name_<2>{  static constexpr auto value = "normal_x"; };
			template <> struct column_name_<3>{  static constexpr auto value = "normal_y"; };
			template <> struct column_name_<4>{  static constexpr auto value = "normal_z"; };
			template <> struct column_name_<5>{  static constexpr auto value = "d"; };
		// clang-format on

		/// @endcond

	  public:
		/// @brief Gets the name of the specified column as a string.
		template <size_type I>
		static constexpr auto& column_name = column_name_<I>::value;

	  private:
		/// @cond

		using table_type = soagen::table<table_traits, allocator_type>;
		table_type table_;

		/// @endcond

	  public:
		/// @brief Default constructor.
		SOAGEN_NODISCARD_CTOR
		planes() = default;

		/// @brief Move constructor.
		SOAGEN_NODISCARD_CTOR
		planes(planes&&) = default;

		/// @brief Move-assignment operator.
		planes& operator=(planes&&) = default;

		/// @brief Copy constructor.
		SOAGEN_NODISCARD_CTOR
		planes(const planes&) = default;

		/// @brief Copy-assignment operator.
		planes& operator=(const planes&) = default;

		/// @brief Destructor.
		~planes() = default;

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit planes(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit planes(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		/// @name Capacity
		/// @{

		/// @brief Returns true if the number of rows is zero.
		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		/// @brief Returns the current number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		/// @brief Returns the maximum possible number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		/// @brief Reserves storage for (at least) the given number of rows.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		planes& reserve(size_type new_cap) noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
			return *this;
		}

		/// @brief Returns the number of rows that can be held in currently allocated storage.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		/// @brief Frees unused capacity.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		planes& shrink_to_fit() noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
			return *this;
		}

		/// @}

		/// @name Modifiers
		/// @{

		/// @brief Removes all rows from table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		planes& clear() noexcept
		{
			table_.clear();
			return *this;
		}

		/// @brief Erases the row at the given index.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void erase(size_type pos) noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
		}

		/// @brief	Erases the row at the given index without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The index of the row that was moved into the erased row's position, if any.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		soagen::optional<size_type> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			return table_.unordered_erase(pos);
		}

		/// @brief Pushes a new row onto the end of the table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		planes& push_back(column_traits<0>::param_type value,
						  column_traits<1>::param_type material,
						  column_traits<2>::param_type normal_x,
						  column_traits<3>::param_type normal_y,
						  column_traits<4>::param_type normal_z,
						  column_traits<5>::param_type d) //
			noexcept(noexcept(std::declval<table_type&>().emplace_back(std::declval<column_traits<0>::param_type&&>(),
																	   std::declval<column_traits<1>::param_type&&>(),
																	   std::declval<column_traits<2>::param_type&&>(),
																	   std::declval<column_traits<3>::param_type&&>(),
																	   std::declval<column_traits<4>::param_type&&>(),
																	   std::declval<column_traits<5>::param_type&&>())))
		{
			table_.emplace_back(static_cast<column_traits<0>::param_type&&>(value),
								static_cast<column_traits<1>::param_type&&>(material),
								static_cast<column_traits<2>::param_type&&>(normal_x),
								static_cast<column_traits<3>::param_type&&>(normal_y),
								static_cast<column_traits<4>::param_type&&>(normal_z),
								static_cast<column_traits<5>::param_type&&>(d));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at the end of the table.
		template <typename... Value,
				  typename... Material,
				  typename... NormalX,
				  typename... NormalY,
				  typename... NormalZ,
				  typename... D>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		planes& emplace_back(soagen::emplacer<Value...>&& value,
							 soagen::emplacer<Material...>&& material,
							 soagen::emplacer<NormalX...>&& normal_x,
							 soagen::emplacer<NormalY...>&& normal_y,
							 soagen::emplacer<NormalZ...>&& normal_z,
							 soagen::emplacer<D...>&& d) //
		{
			table_.emplace_back(static_cast<soagen::emplacer<Value...>&&>(value),
								static_cast<soagen::emplacer<Material...>&&>(material),
								static_cast<soagen::emplacer<NormalX...>&&>(normal_x),
								static_cast<soagen::emplacer<NormalY...>&&>(normal_y),
								static_cast<soagen::emplacer<NormalZ...>&&>(normal_z),
								static_cast<soagen::emplacer<D...>&&>(d));
			return *this;
		}

		/// @brief Removes the last row(s) from the table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		planes& pop_back(size_type num = 1) noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
			return *this;
		}

		/// @brief Resizes the table to the given number of rows.
		///
		/// @availability This method is only available when all the column types are default-constructible.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_resize_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		planes& resize(size_type new_size) noexcept(soagen::has_nothrow_resize_member<table_type, size_type>)
		{
			table_.resize(new_size);
			return *this;
		}

		/// @brief Swaps the contents of the table with another.
		///
		/// @availability This method is only available when #allocator_type is swappable (or non-propagating).
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		constexpr void swap(planes& other) noexcept(soagen::has_nothrow_swap_member<table_type>)
		{
			table_.swap(other.table_);
		}

		/// @}

		/// @name Element access
		/// @{

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::all_trivially_copyable)
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr std::byte* data() noexcept
		{
			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, 0>>(
				table_.data());
		}

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::all_trivially_copyable)
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const std::byte* data() const noexcept
		{
			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, 0>>(
				table_.data());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <size_t I>
		SOAGEN_ALIGNED_COLUMN(I)
		column_type<I>* column() noexcept
		{
			static_assert(I < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, I>>(
				table_.template column<I>());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <size_t I>
		SOAGEN_ALIGNED_COLUMN(I)
		std::add_const_t<column_type<I>>* column() const noexcept
		{
			static_assert(I < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, I>>(
				table_.template column<I>());
		}

		/// @brief Returns a pointer to the elements in column [0]: value.
		SOAGEN_ALIGNED_COLUMN(0)
		rt::plane* value() noexcept
		{
			return column<0>();
		}

		/// @brief Returns a pointer to the elements in column [0]: value.
		SOAGEN_ALIGNED_COLUMN(0)
		const rt::plane* value() const noexcept
		{
			return column<0>();
		}

		/// @brief Returns a pointer to the elements in column [1]: material.
		SOAGEN_ALIGNED_COLUMN(1)
		size_t* material() noexcept
		{
			return column<1>();
		}

		/// @brief Returns a pointer to the elements in column [1]: material.
		SOAGEN_ALIGNED_COLUMN(1)
		const size_t* material() const noexcept
		{
			return column<1>();
		}

		/// @brief Returns a pointer to the elements in column [2]: normal_x.
		SOAGEN_ALIGNED_COLUMN(2)
		float* normal_x() noexcept
		{
			return column<2>();
		}

		/// @brief Returns a pointer to the elements in column [2]: normal_x.
		SOAGEN_ALIGNED_COLUMN(2)
		const float* normal_x() const noexcept
		{
			return column<2>();
		}

		/// @brief Returns a pointer to the elements in column [3]: normal_y.
		SOAGEN_ALIGNED_COLUMN(3)
		float* normal_y() noexcept
		{
			return column<3>();
		}

		/// @brief Returns a pointer to the elements in column [3]: normal_y.
		SOAGEN_ALIGNED_COLUMN(3)
		const float* normal_y() const noexcept
		{
			return column<3>();
		}

		/// @brief Returns a pointer to the elements in column [4]: normal_z.
		SOAGEN_ALIGNED_COLUMN(4)
		float* normal_z() noexcept
		{
			return column<4>();
		}

		/// @brief Returns a pointer to the elements in column [4]: normal_z.
		SOAGEN_ALIGNED_COLUMN(4)
		const float* normal_z() const noexcept
		{
			return column<4>();
		}

		/// @brief Returns a pointer to the elements in column [5]: d.
		SOAGEN_ALIGNED_COLUMN(5)
		float* d() noexcept
		{
			return column<5>();
		}

		/// @brief Returns a pointer to the elements in column [5]: d.
		SOAGEN_ALIGNED_COLUMN(5)
		const float* d() const noexcept
		{
			return column<5>();
		}

		/// @}

		/// @brief Returns the allocator being used by the table.
		SOAGEN_INLINE_GETTER
		constexpr allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}
	};

	/// @brief Swaps the contents of two instances of #rt::planes.
	///
	/// @availability	This overload is only available when #rt::planes::allocator_type
	/// is swappable (or non-propagating).
	SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<planes>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(planes& lhs, planes& rhs) //
		noexcept(soagen::has_nothrow_swap_member<planes>)
	{
		lhs.swap(rhs);
	}

	/// @cond

	/// @endcond

	/// @}

	/// @}
}

//----------------------------------------------------------------------------------------------------------------------
// spheres
//----------------------------------------------------------------------------------------------------------------------

namespace rt
{
	/// @addtogroup soa Struct-of-Arrays
	/// @{

	/// @addtogroup soa_spheres spheres
	/// @{

	/// @brief spheres
	///
	/// @note The code for this class was generated by soagen - https://github.com/marzer/soagen
	class spheres
	{
	  private:
		/// @cond

		template <typename ValueType,
				  typename ParamType = soagen::param_type<ValueType>,
				  size_t Align		 = alignof(ValueType)>
		using make_col = soagen::column_traits<ValueType, ParamType, soagen::max(Align, alignof(ValueType))>;

		/// @endcond

	  public:
		using size_type		  = std::size_t;
		using difference_type = std::ptrdiff_t;

		/// @brief The allocator type used by this class.
		using allocator_type = soagen::allocator;

		/// @brief The traits for the entire table.
		using table_traits = soagen::table_traits<
			/*	  value */ make_col<rt::sphere>,
			/* material */ make_col<size_t>,
			/* center_x */ make_col<float, soagen::param_type<float>, 32>,
			/* center_y */ make_col<float, soagen::param_type<float>, 32>,
			/* center_z */ make_col<float, soagen::param_type<float>, 32>,
			/*	 radius */ make_col<float, soagen::param_type<float>, 32>>;

		/// @brief Gets the traits for a specific column of the table.
		template <size_type I>
		using column_traits = typename table_traits::template column<I>;

		/// @brief Gets the type of a specific column in the table.
		template <size_type I>
		using column_type = typename column_traits<I>::value_type;

		/// @brief The amount of rows to advance to maintain the requested alignment
		///
		/// @details The multiple of rows you need to advance through the table such that
		/// all elements across all columns have the same memory alignment as the beginning of their column
		/// (i.e. they are 'perfectly aligned' with the chosen value for `alignment` in the soagen config).
		///
		/// @note Typically you can ignore this; column elements are always aligned correctly according to their type.
		/// This is for over-alignment scenarios where you need to do things in batches (e.g. SIMD).
		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		struct column_indices
		{
			static constexpr size_type value	= 0;
			static constexpr size_type material = 1;
			static constexpr size_type center_x = 2;
			static constexpr size_type center_y = 3;
			static constexpr size_type center_z = 4;
			static constexpr size_type radius	= 5;
		};

	  private:
		/// @cond
		// clang-format off
			template <size_type> struct column_name_{};
			template <> struct column_name_<0>{  static constexpr auto value = "value"; };
			template <> struct column_name_<1>{  static constexpr auto value = "material"; };
			template <> struct column_name_<2>{  static constexpr auto value = "center_x"; };
			template <> struct column_name_<3>{  static constexpr auto value = "center_y"; };
			template <> struct column_name_<4>{  static constexpr auto value = "center_z"; };
			template <> struct column_name_<5>{  static constexpr auto value = "radius"; };
		// clang-format on

		/// @endcond

	  public:
		/// @brief Gets the name of the specified column as a string.
		template <size_type I>
		static constexpr auto& column_name = column_name_<I>::value;

	  private:
		/// @cond

		using table_type = soagen::table<table_traits, allocator_type>;
		table_type table_;

		/// @endcond

	  public:
		/// @brief Default constructor.
		SOAGEN_NODISCARD_CTOR
		spheres() = default;

		/// @brief Move constructor.
		SOAGEN_NODISCARD_CTOR
		spheres(spheres&&) = default;

		/// @brief Move-assignment operator.
		spheres& operator=(spheres&&) = default;

		/// @brief Copy constructor.
		SOAGEN_NODISCARD_CTOR
		spheres(const spheres&) = default;

		/// @brief Copy-assignment operator.
		spheres& operator=(const spheres&) = default;

		/// @brief Destructor.
		~spheres() = default;

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit spheres(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit spheres(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		/// @name Capacity
		/// @{

		/// @brief Returns true if the number of rows is zero.
		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		/// @brief Returns the current number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		/// @brief Returns the maximum possible number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		/// @brief Reserves storage for (at least) the given number of rows.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& reserve(size_type new_cap) noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
			return *this;
		}

		/// @brief Returns the number of rows that can be held in currently allocated storage.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		/// @brief Frees unused capacity.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& shrink_to_fit() noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
			return *this;
		}

		/// @}

		/// @name Modifiers
		/// @{

		/// @brief Removes all rows from table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& clear() noexcept
		{
			table_.clear();
			return *this;
		}

		/// @brief Erases the row at the given index.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void erase(size_type pos) noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
		}

		/// @brief	Erases the row at the given index without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The index of the row that was moved into the erased row's position, if any.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		soagen::optional<size_type> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			return table_.unordered_erase(pos);
		}

		/// @brief Pushes a new row onto the end of the table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& push_back(column_traits<0>::param_type value,
						   column_traits<1>::param_type material,
						   column_traits<2>::param_type center_x,
						   column_traits<3>::param_type center_y,
						   column_traits<4>::param_type center_z,
						   column_traits<5>::param_type radius) //
			noexcept(noexcept(std::declval<table_type&>().emplace_back(std::declval<column_traits<0>::param_type&&>(),
																	   std::declval<column_traits<1>::param_type&&>(),
																	   std::declval<column_traits<2>::param_type&&>(),
																	   std::declval<column_traits<3>::param_type&&>(),
																	   std::declval<column_traits<4>::param_type&&>(),
																	   std::declval<column_traits<5>::param_type&&>())))
		{
			table_.emplace_back(static_cast<column_traits<0>::param_type&&>(value),
								static_cast<column_traits<1>::param_type&&>(material),
								static_cast<column_traits<2>::param_type&&>(center_x),
								static_cast<column_traits<3>::param_type&&>(center_y),
								static_cast<column_traits<4>::param_type&&>(center_z),
								static_cast<column_traits<5>::param_type&&>(radius));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at the end of the table.
		template <typename... Value,
				  typename... Material,
				  typename... CenterX,
				  typename... CenterY,
				  typename... CenterZ,
				  typename... Radius>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& emplace_back(soagen::emplacer<Value...>&& value,
							  soagen::emplacer<Material...>&& material,
							  soagen::emplacer<CenterX...>&& center_x,
							  soagen::emplacer<CenterY...>&& center_y,
							  soagen::emplacer<CenterZ...>&& center_z,
							  soagen::emplacer<Radius...>&& radius) //
		{
			table_.emplace_back(static_cast<soagen::emplacer<Value...>&&>(value),
								static_cast<soagen::emplacer<Material...>&&>(material),
								static_cast<soagen::emplacer<CenterX...>&&>(center_x),
								static_cast<soagen::emplacer<CenterY...>&&>(center_y),
								static_cast<soagen::emplacer<CenterZ...>&&>(center_z),
								static_cast<soagen::emplacer<Radius...>&&>(radius));
			return *this;
		}

		/// @brief Removes the last row(s) from the table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& pop_back(size_type num = 1) noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
			return *this;
		}

		/// @brief Resizes the table to the given number of rows.
		///
		/// @availability This method is only available when all the column types are default-constructible.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_resize_member<table_type, size_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& resize(size_type new_size) noexcept(soagen::has_nothrow_resize_member<table_type, size_type>)
		{
			table_.resize(new_size);
			return *this;
		}

		/// @brief Swaps the contents of the table with another.
		///
		/// @availability This method is only available when #allocator_type is swappable (or non-propagating).
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		constexpr void swap(spheres& other) noexcept(soagen::has_nothrow_swap_member<table_type>)
		{
			table_.swap(other.table_);
		}

		/// @}

		/// @name Element access
		/// @{

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::all_trivially_copyable)
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr std::byte* data() noexcept
		{
			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, 0>>(
				table_.data());
		}

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::all_trivially_copyable)
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const std::byte* data() const noexcept
		{
			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, 0>>(
				table_.data());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <size_t I>
		SOAGEN_ALIGNED_COLUMN(I)
		column_type<I>* column() noexcept
		{
			static_assert(I < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, I>>(
				table_.template column<I>());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <size_t I>
		SOAGEN_ALIGNED_COLUMN(I)
		std::add_const_t<column_type<I>>* column() const noexcept
		{
			static_assert(I < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::detail::actual_column_alignment<table_traits, allocator_type, I>>(
				table_.template column<I>());
		}

		/// @brief Returns a pointer to the elements in column [0]: value.
		SOAGEN_ALIGNED_COLUMN(0)
		rt::sphere* value() noexcept
		{
			return column<0>();
		}

		/// @brief Returns a pointer to the elements in column [0]: value.
		SOAGEN_ALIGNED_COLUMN(0)
		const rt::sphere* value() const noexcept
		{
			return column<0>();
		}

		/// @brief Returns a pointer to the elements in column [1]: material.
		SOAGEN_ALIGNED_COLUMN(1)
		size_t* material() noexcept
		{
			return column<1>();
		}

		/// @brief Returns a pointer to the elements in column [1]: material.
		SOAGEN_ALIGNED_COLUMN(1)
		const size_t* material() const noexcept
		{
			return column<1>();
		}

		/// @brief Returns a pointer to the elements in column [2]: center_x.
		SOAGEN_ALIGNED_COLUMN(2)
		float* center_x() noexcept
		{
			return column<2>();
		}

		/// @brief Returns a pointer to the elements in column [2]: center_x.
		SOAGEN_ALIGNED_COLUMN(2)
		const float* center_x() const noexcept
		{
			return column<2>();
		}

		/// @brief Returns a pointer to the elements in column [3]: center_y.
		SOAGEN_ALIGNED_COLUMN(3)
		float* center_y() noexcept
		{
			return column<3>();
		}

		/// @brief Returns a pointer to the elements in column [3]: center_y.
		SOAGEN_ALIGNED_COLUMN(3)
		const float* center_y() const noexcept
		{
			return column<3>();
		}

		/// @brief Returns a pointer to the elements in column [4]: center_z.
		SOAGEN_ALIGNED_COLUMN(4)
		float* center_z() noexcept
		{
			return column<4>();
		}

		/// @brief Returns a pointer to the elements in column [4]: center_z.
		SOAGEN_ALIGNED_COLUMN(4)
		const float* center_z() const noexcept
		{
			return column<4>();
		}

		/// @brief Returns a pointer to the elements in column [5]: radius.
		SOAGEN_ALIGNED_COLUMN(5)
		float* radius() noexcept
		{
			return column<5>();
		}

		/// @brief Returns a pointer to the elements in column [5]: radius.
		SOAGEN_ALIGNED_COLUMN(5)
		const float* radius() const noexcept
		{
			return column<5>();
		}

		/// @}

		/// @brief Returns the allocator being used by the table.
		SOAGEN_INLINE_GETTER
		constexpr allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}
	};

	/// @brief Swaps the contents of two instances of #rt::spheres.
	///
	/// @availability	This overload is only available when #rt::spheres::allocator_type
	/// is swappable (or non-propagating).
	SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<spheres>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(spheres& lhs, spheres& rhs) //
		noexcept(soagen::has_nothrow_swap_member<spheres>)
	{
		lhs.swap(rhs);
	}

	/// @cond

	/// @endcond

	/// @}

	/// @}
}

//----------------------------------------------------------------------------------------------------------------------
// template specializations
//----------------------------------------------------------------------------------------------------------------------

/// @cond

namespace soagen
{
	template <>
	inline constexpr bool is_soa<rt::boxes> = true;

	template <>
	inline constexpr bool is_soa<rt::materials> = true;

	template <>
	inline constexpr bool is_soa<rt::planes> = true;

	template <>
	inline constexpr bool is_soa<rt::spheres> = true;
}

/// @endcond

#if SOAGEN_MSVC_LIKE
	#pragma pop_macro("min")
	#pragma pop_macro("max")
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(off)
#endif
SOAGEN_POP_WARNINGS;
